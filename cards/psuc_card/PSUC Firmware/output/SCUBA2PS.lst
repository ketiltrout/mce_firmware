C51 COMPILER V8.04   SCUBA2PS                                                              03/26/2007 13:32:42 PAGE 1   


C51 COMPILER V8.04, COMPILATION OF MODULE SCUBA2PS
OBJECT MODULE PLACED IN .\output\SCUBA2PS.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE SCUBA2PS.C COMPACT ROM(COMPACT) MODP2 DEBUG OBJECTEXTEND PRINT(.\output\SCU
                    -BA2PS.lst) OBJECT(.\output\SCUBA2PS.obj)

line level    source

   1          /************************************************************************************/
   2          /*      Scuba 2 Power Supply Controller - SC2_ELE_S565_102D
   3                          Tom Felton - Feb 22, 2006
   4                          Stuart Hadfield - July/August 2006               
   5          /************************************************************************************/
   6          // Revision history: 
   7          // $Log: scuba2ps.c,v $
   8          //
   9          // Version 3.2 22-March-2007 RHJ
  10          //
  11          // Version 3.1 15-March-2007 RHJ
  12          //
  13          // Revision 1.13  2006/12/23 00:39:00  stuartah
  14          // Version 2.3 Release
  15          //
  16          // Revision 1.12  2006/11/22 00:10:08  stuartah
  17          // Fixed FAULT LED behavior to turn on if no CC request for over a minute (no longer flashes)
  18          //
  19          // Revision 1.11  2006/11/21 23:30:40  stuartah
  20          // Added soft_reset assembly code, triggered via external button (timer2 input)
  21          //
  22          // Revision 1.10  2006/11/21 21:25:41  stuartah
  23          // Implemented Timer2 as external interrupt
  24          //
  25          // Revision 1.9  2006/11/20 23:22:00  stuartah
  26          // Cleaned code, improved commenting, implemented changes for PSUC rev. G
  27          //
  28          // Revision 1.8  2006/10/03 07:38:34  stuartah
  29          // Added presence detection of DS18S20s
  30          //
  31          // Revision 1.7  2006/10/03 05:59:12  stuartah
  32          // Tested in Subrack, Basic Command working
  33          //
  34          // Revision 1.6  2006/09/07 20:37:01  stuartah
  35          // Cleaned up init() and re-organized main loop structure
  36          //
  37          // Revision 1.5  2006/09/05 20:06:20  stuartah
  38          // Changed i2c.c to MAX1271.c (code for interfacing ADCs, does not use i2c protocol)
  39          //
  40          // Revision 1.4  2006/08/31 19:30:38  stuartah
  41          // Added functionality for measuring fan speeds
  42          //
  43          // Revision 1.3  2006/08/30 19:54:19  stuartah
  44          // Implemented checksum
  45          //
  46          // Revision 1.2  2006/08/29 21:06:06  stuartah
  47          // Initial CVS Build - Most Basic Functionality Implemented
  48          //      
  49          /********************************************************************************       
  50          Refer to the following Data Sheets:
  51                          Processor - Atmel AT89C5131AM
  52                          Temperature Monitoring & Silicon ID - Dallas DS18S20-PAR
  53                          ADC for Power Supply Voltage Monitoring - Maxim MAX1270ACAI
  54                          EEPROM non-volatile memory - Atmel AT25128A
C51 COMPILER V8.04   SCUBA2PS                                                              03/26/2007 13:32:42 PAGE 2   

  55          
  56                  NOTE: THIS PROGRAM IS NO WHERE NEAR COMPLETE OR TESTED
  57                  The I/O pins are set correctly for this version (revF).
  58          *********************************************************************************/
  59          
  60          /**********     Version 2.2     *****************
  61          Polling and communication functionality seems to be working     */
  62          
  63          
  64          // Header File containing function prototypes and global variable declarations
  65          #include "scuba2ps.h"
*** WARNING C182 IN LINE 112 OF MAX1271.C: pointer to different objects
  66          
  67          // Constant Variables
  68          char code software_version_byte = 0x32;                                         // 1 byte Software Version 
  69          char code prompt[] =  "\rPSC> ";                                                        // RS232 IO prompt
  70          
  71          // Software Version and Help List of Commands Serial Message
  72          char code helpmsg[] = "\r\r\tPSUC v3.2\r\
  73          \t?  This stuff.\r\
  74          \tc  Cycle Power.\r\
  75          \tf  Turn PSU off.\r\
  76          \tn  Turn PSU on.\r\
  77          \tr  Reset MCE BSRT.\r\
  78          \td  PSU data block.\r\
  79          \tt  Temperatures in hex.\r\
  80          \tv  PSU voltages.\r\
  81          \ti  PSU currents.\r";
  82          //
  83          
  84          /****************************************************************************************
  85           *  Main Program                           *
  86           *************************** */
  87          
  88          main() 
  89          { 
  90   1              // Initialize Hardware and Software Variables
  91   1              init();                                                                                 
  92   1              
  93   1              // Output Version + Help on Serial Port
  94   1              snd_msg(helpmsg);
  95   1                      
  96   1              // Initial Power-Up
  97   1              sequence_on();                          
  98   1              
  99   1      //      _nop_();        // << THIS IS THE SOFT_RESET JUMP-TO POINT      
 100   1      //      if( ET2 == 0) snd_msg("\rRestarting\r");        
 101   1      //      LED_STATUS = OFF;               // used as soft-reset test o/p; on P1-pin3
 102   1      //      wait_time( 600 );                       // wait 3 seconds for button release and any bounces
 103   1      //      TF2 = 0;                                        // clear any interrupt
 104   1      //      ET2 = 1;                                        // Enable Timer2 soft_reset Interrupts
 105   1              
 106   1              snd_msg(prompt);
 107   1                
 108   1              /***  Main Loop - Periodically update PSU data block, respond to Clock Card / RS232 Commands  ***/
 109   1              while(TRUE) {                                                           
 110   2      
 111   2                      // Serial I/O message ready to parse
 112   2                      if ( sio_msg_complete == SET ) {
 113   3                              ES = 0;                                         // Disable SIO Interrupts                                       
 114   3                      sio_msg_complete = CLEAR;
 115   3                              sio_rx_idx = 0;                         // reset message pointer
C51 COMPILER V8.04   SCUBA2PS                                                              03/26/2007 13:32:42 PAGE 3   

 116   3                              switch ( sio_rxbuf[0] ) {       // parse message
 117   4                                      case 'c':                               // Cycle Power Command
 118   4                                              cycle_power();
 119   4                                              break;
 120   4                                              
 121   4                                      case 'r':                               // Reset MCE Command
 122   4                                              reset_MCE();
 123   4                                              break;
 124   4      
 125   4                                      case '?':                               // Respond with Software Version
 126   4                                              snd_msg(helpmsg);       // and a help list of commands
 127   4                                              break;
 128   4      
 129   4                                      case 'd':                               // Respond with PSU data block          
 130   4                                              sio_prt_datablk_hex();
 131   4                                              break;                                  
 132   4                        
 133   4                                      case 't':                               // Respond with PSU data block temperatures             
 134   4                                              sio_prt_temps_hex();
 135   4                                              break;
 136   4                                                                                      
 137   4                                      case 'f':                               // Turn Off Command
 138   4                                              sequence_off();
 139   4                                              break;
 140   4                                              
 141   4                                      case 'n':                               // Turn On Command
 142   4                                              sequence_on();
 143   4                                              break;
 144   4                                              
 145   4                                      case 'i':                               // output PSU voltages          
 146   4                                              sio_prt_currents() ;
 147   4                                              break;                                  
 148   4      
 149   4                                      case 'v':                               // output PSU voltages          
 150   4                                              sio_prt_volts() ;
 151   4                                              break;                                  
 152   4      
 153   4                                      default:
 154   4                                              snd_msg("\tWHAT?");
 155   4                                              break;
 156   4                              }
 157   3                              sio_rxbuf[0] = 0;
 158   3                              ES = 1;                                         // Enable SIO Interrupts
 159   3                              snd_msg(prompt);
 160   3                      }
 161   2      
 162   2                      // Listen for data request from clock card
 163   2                      cc_spi = ~SREQ;                                                                 // SREQ active low
 164   2      
 165   2                      // Time to re-poll data
 166   2                      if ( poll_data == SET ) {                                               // polling rate ~ 3Hz, CC Request Rate ~ 0.5Hz                  
 167   3                              update_data_block();
 168   3                              poll_data = CLEAR;                                                      // Data Poll Complete
 169   3                              *DATABLK_UPDATED = TRUE;                                                // flag that data_blk has been updated                                                                                                                  
 170   3                      }
 171   2                      
 172   2                      // Send data block if it has been requested
 173   2                      if ( cc_spi == TRUE) {                                     
 174   3                              cc_req_320ms = 0;                                                       // Reset count since last CC request
 175   3                              LED_FAULT = 0;                                                          // Turn Off LED if on
 176   3                              send_psu_data_block();                                          // Time to send SPI Data to Clock Card
 177   3                              cc_spi = FALSE;                                                         // Data Block Transmission Complete
C51 COMPILER V8.04   SCUBA2PS                                                              03/26/2007 13:32:42 PAGE 4   

 178   3                              *DATABLK_UPDATED = FALSE;                                       // flag that data_blk info is 'old'
 179   3                      }
 180   2              
 181   2                      // Act on command from Clock Card
 182   2                      if ( cc_command != NULL )               
 183   2                              switch ( *cc_command ) {                                        // parse received command       
 184   3                                      
 185   3                                      case 'C':                                                               // Cycle Power Command
 186   3                                              cycle_power();
 187   3                                              cc_command = NULL;
 188   3                                              break;
 189   3                                      
 190   3                                      case 'R':                                                               // Reset MCE Command
 191   3                                              reset_MCE();
 192   3                                              cc_command = NULL;
 193   3                                              break;
 194   3      
 195   3                                      case 'T':                                                               // Turn Off Command
 196   3                                              sequence_off();
 197   3                                              cc_command = NULL;
 198   3                                              break;
 199   3      
 200   3                              default:                                                                // Status Request or erroneous command.  Difference is ACK/NAK.
 201   3                                              cc_command = NULL;
 202   3                                              break;  
 203   3                      }
 204   2      
 205   2                      // Loop Maintenance                     
 206   2                      if (cc_req_320ms > 187) {                                               // if its been more than a minute since last CC request, 187*320ms = 
 207   3                                      LED_FAULT = 1;                                                  // then turn on fault LED
 208   3                      }
 209   2      
 210   2                      watchdog_count = 0;                                                             // clear watchdog counter
 211   2      
 212   2              }
 213   1      }
 214          
 215          /****************************************************************************************
 216           *  Initialize                     *
 217           *************************** */
 218          
 219          void init(void)
 220          {
 221   1              int i = 0;                                      // temporary index variable
 222   1      
 223   1      /**************         Hardware Setup          **************/
 224   1              // Set all input ports for input and output ports to default values     -- see schematic and io.h
 225   1              // IO Port Setup  --  1=Input(or Special Function), 0=Output
 226   1              P0 = 0x66;              //0110 0110             //****** changed to acomidate SSTRB lines in Rev G ******
 227   1              //P0 = 0x60;    //0110 0000
 228   1              P1 = 0xff;              //1111 1111
 229   1              P2 = 0xbe;              //1011 1110             // Intialize PSU OFF
 230   1              P3 = 0xdf;              //1101 1111
 231   1      
 232   1              /* SPI setup                            -- these declarations are redundant.  done in port settings above                               
 233   1              CS_EEPROM = 1;                          // CableSelect lines active low 
 234   1              CS_VADC = 1;
 235   1              CS_IADC = 1;
 236   1              CCSS=1;
 237   1              //SREQ = 0;                                     // SREQ active low but this is needed to not overload buffer U5 - PROTOTYPE PSUC REV F ON
             -LY
 238   1              SREQ = 1;                                       // Port bit set for input -- REV G ONLY
C51 COMPILER V8.04   SCUBA2PS                                                              03/26/2007 13:32:42 PAGE 5   

 239   1              MISO = 1;                                       // Set for input
 240   1              MOSI = 1;         */
 241   1              
 242   1              // Counter/Timer 0 used as a Timer in Mode 1.  Interrupt Rate: 32mS     
 243   1              TH0 = 0;
 244   1              TL0 = 135;
 245   1              TR0 = ON;                                       // start timer 0
 246   1      
 247   1              // Counter/Timer 1 used as a Timer in Mode 1.  Interrupt Rate: 5e-3 Sec
 248   1              TL1 = LS_RELOAD_5mS;
 249   1              TH1 = MS_RELOAD_5mS;
 250   1              TMOD = 0x11;
 251   1      
 252   1              // Timer 2 used as count up counter for soft reset function, triggered when external reset button pushed
 253   1              T2CON = 0x02;                   // 0b00000010 -- set for counter operation, external trigger on T2 pin
 254   1              TH2 = 0xFF;                                     // set counter so single external trigger causes interrupt -> soft reset
 255   1              TL2 = 0xFF;
 256   1              RCAP2H = 0xFF;                          // same auto-reload values                              
 257   1              RCAP2L = 0xFF;
 258   1              TR2 = 1;                                        // start timer 2
 259   1      
 260   1              // Serial I/O Setup:  Using Internal Baud Rate Generator on 89C5131A.  Set to Serial Mode 1 at 9600 Baud 
             -using 24MHz Clock
 261   1          SCON = 0x50;                                // 0101 0000
 262   1              BDRCON = 0x1e;                          // 0001 1110
 263   1              CKCON0 = 0x7f;                          // X2 set but 12 clocks per peripheral cycle -> 500ns pert tick
 264   1              PCON = 0x80;                            // 1000 0000 Double Baud Rate all others default
 265   1              BRL = 100;                                      // Baud rate reload - sets Baud rate to 9600
 266   1      
 267   1              //PCA Counter Init                      // not implemented      - for getFanSpeed()
 268   1              //CKCON0 |= 0x20;                       // sets to 500ns per PCA tick
 269   1              //CMOD |= 0x81;                         // 1000 0001 Set PCA to stop counting during idle mode, disable PCA interrupts, and co
             -unt Fclk-periph/6 (250ns period)
 270   1              //CCON |= 0x01;                         // enable PCA interrupts 
 271   1      
 272   1              // LED Setup
 273   1              LEDCON = 0xfC;                          // LED1-3 10mA Current Source
 274   1              LED_FAULT = 0;                          // Off
 275   1      //      LED_STATUS = 1;                         // Off
 276   1              LED_STATUS = 0;                         // Used as test o/p
 277   1              LED_OUTON = 1;                          // Off
 278   1      
 279   1              // SPI Setup - Sets up spi in master mode with Fclk Periph/16 as baud rate and without slave select pin.
 280   1              // SPCON = SPI_MSTR | SPI_EN | SPI_SSDIS | SPI_CPOL1 | SPI_1M5Hz;       CPHA = 0, transfer on falling SCLK
 281   1          SPCON |= SPI_MSTR;          // Master mode    
 282   1              //SPCON |= SPI_6MHz;            // Fclk Periph/4 (6MHz)
 283   1          SPCON |= SPI_1M5Hz;                 // Fclk Periph/16 (1.5Mhz)
 284   1              SPCON &= SPI_CPOL0;             // CPOL = 0, Clk idle state 0
 285   1          SPCON &= SPI_CPHA0;         // CPHA = 0, sample data on Clk rising edge
 286   1          SPCON |= SPI_SSDIS;                 // Disable SS
 287   1          SPCON |= SPI_EN;            // Run SPI
 288   1          
 289   1              // Interrupt Setup
 290   1              ES = 1;                                         // Enable SIO Interrupts
 291   1              IEN1 |= 0x04;               // Enable SPI Interrupts
 292   1              ET0 = 1;                                // Enable Timer0 Interrupts
 293   1          ET1 = 1;                                    // Enable Timer1 Interrupts
 294   1      //      ET2 = 1;                                        // Enable Timer2 Interrupts
 295   1          EA = 1;                                     // Enable Global Interrupts
 296   1              //EC = 1;                                       // Enable all PCA Interrupts
 297   1      
 298   1              // Interrupt Priority Setup
C51 COMPILER V8.04   SCUBA2PS                                                              03/26/2007 13:32:42 PAGE 6   

 299   1              PT0L = 1;                                       // give Timer0 a higher priority
 300   1              
 301   1      
 302   1      /****************       Initialize Variables    ********************/           // Some of this is redundant                                                    
 303   1              // Initialize flags
 304   1              poll_data = SET;                        // Initial data poll
 305   1              cc_spi = CLEAR;                         // Clear remaining flags
 306   1              spi_complete = CLEAR;           // SPI transmission/reception complete status bit
 307   1              sio_msg_complete = CLEAR;
 308   1              timeup_T1 = CLEAR;
 309   1                      
 310   1              // Initialize other vars        
 311   1              spi_idx = 0;                            // Reset pointer for SPI data output
 312   1              sio_rx_idx = 0;                         // reset serial message pointer
 313   1              bcnt = 0;
 314   1              num_T1_ints = 0;
 315   1              running_checksum = 0;
 316   1              cc_req_320ms = 0;
 317   1              watchdog_count = 0;
 318   1              
 319   1              // Initialize pointers
 320   1              cc_command = NULL;
 321   1              msg_ptr = NULL;
 322   1                      
 323   1              // Initialize data blocks to all zeros
 324   1              for(i=0; i < CC_SPI_BLEN; i++) {                                
 325   2                              ps_data_blk[i] = 0;                                     
 326   2                              rcv_spi_blk[i] = 0;
 327   2              }
 328   1              for(i=0; i < BUF_SIZE; i++) {                           
 329   2                              sio_rxbuf[i] = 0;       
 330   2              }
 331   1              
 332   1              // Initialize PSU data block - these aspects of data block set only once
 333   1              ds_get_4byte_id(PSU_DS18S20, SILICON_ID);        // assign ID to PSU block
 334   1              *SOFTWARE_VERSION = software_version_byte;       // Software Version byte
 335   1      
 336   1      
 337   1      /*****************              Initialize Devices              ***************/        
 338   1              // check for presence of DS18S20 temperature sensors    
 339   1              temp1_present = ds_initialize(PSU_DS18S20);             
 340   1              temp2_present = ds_initialize(DTEMP1_ID);
 341   1              temp3_present = ds_initialize(DTEMP2_ID);       
 342   1      }
 343          
 344          /****************************************************************************************
 345           *  Turn-On (Startup) Sequence             *
 346           ***************************/
 347          
 348          void sequence_on (void)
 349          {
 350   1              //wait_time( T100mS );
 351   1              nPSU_ON = 0;
 352   1              wait_time( T100mS );
 353   1              nCORE_ON = 0;
 354   1              LED_OUTON = 0;                                                          // 0 = LED on
 355   1      }
 356          
 357          /****************************************************************************************
 358           *  Turn-Off Sequence              *
 359           *******************************/
 360          
C51 COMPILER V8.04   SCUBA2PS                                                              03/26/2007 13:32:42 PAGE 7   

 361          void sequence_off (void)
 362          {
 363   1              nCORE_ON = 1;
 364   1              wait_time( T100mS );
 365   1              nPSU_ON = 1;
 366   1          wait_time( T100mS );
 367   1              LED_OUTON = 1;                                                          // LED off
 368   1      }
 369          
 370          /****************************************************************************************
 371           *  Reset MCE      *
 372           *******************/
 373          
 374          void reset_MCE (void)
 375          {
 376   1              BRST = 1;                                       // Pulse Reset Line
 377   1      //      wait_time( 400 );                       // wait 2 second
 378   1              wait_time( 800 );                       // wait 4 second
 379   1              BRST = 0;
 380   1      }
 381          
 382          /****************************************************************************************
 383           *  Cycle Power            *
 384           ***********************/
 385          
 386          void cycle_power (void)
 387          {
 388   1              sequence_off();
 389   1      //      wait_time( 400 );                       // wait 2 seconds
 390   1              wait_time( 800 );                       // wait 4 seconds
 391   1              sequence_on();
 392   1      }
 393          
 394          /****************************************************************************************
 395          /*      Send PSU Data Block to CC via SPI          *
 396          /*******************************************/
 397          // Sends the 36 byte PSU Status Block to the CC via SPI interface while simultaneously 
 398          // receiving a command from the CC.  ACK/NAK byte near end of datablock indicates whether
 399          // a valid command was received during the SAME datablock transmission.
 400          
 401          void send_psu_data_block (void)
 402          {                               
 403   1              // Begin Transaction
 404   1              spi_idx = 0;                                                            // Start at beginning of data block
 405   1              CCSS = 0;                                                                       // Select Clock Card (as slave) to listen on SPI bus            
 406   1                              
 407   1              // Send first 34 of 36 bytes (need to calculate checksum based on ACK/NAK byte after CC command recv'd)
 408   1              while(spi_idx < ACK_BYTE_POS) {                         
 409   2                      SPDAT = ps_data_blk[spi_idx];                   // send byte #spi_idx
 410   2                      while(!spi_complete);                                   // wait for end of byte transmission
 411   2                      spi_complete = 0;                                               // clear software flag
 412   2                      spi_idx++;                                                              // increment data block index
 413   2              }
 414   1              
 415   1              // Update ACK/NAK byte and send
 416   1              parse_command();                                                        // Check if command received and set ACK/NAK byte
 417   1      
 418   1              // Send ACK/NAK byte
 419   1              SPDAT = ps_data_blk[ACK_BYTE_POS];              
 420   1              while(!spi_complete);                                           // wait for end of byte transmission
 421   1              spi_complete = 0;                                                       // clear software flag
 422   1              
C51 COMPILER V8.04   SCUBA2PS                                                              03/26/2007 13:32:42 PAGE 8   

 423   1              // Update Checkbyte and send            
 424   1              COMPLETE_CHECKSUM;                                                      // 2's compliment, so CHECKSUM_BYTE + all other bytes = 0       
 425   1              SPDAT = ps_data_blk[ACK_BYTE_POS + 1];          // Send Check byte
 426   1              while(!spi_complete);                                           // wait for end of byte transmission
 427   1              spi_complete = 0;                                                       // clear software flag
 428   1                      
 429   1              // Finish Transaction
 430   1              CCSS = 1;                                                                       // De-select Clock Card                                 
 431   1      }
 432          
 433          /****************************************************************************************
 434          /*  Wait Timer - 5ms Multiples             */
 435          /***************************************/
 436          //Sets up T1 interrupt to loops x 5mS, waits specified time then returns
 437           
 438          void wait_time (unsigned int loops)
 439          {
 440   1              timeup_T1 = CLEAR;
 441   1              TL1 = LS_RELOAD_5mS;                                            // Interrupt interval set to 5mS
 442   1              TH1 = MS_RELOAD_5mS;
 443   1              num_T1_ints = loops;                                            // time expires after 1 interrupt
 444   1              TR1 = ON;
 445   1              while ( timeup_T1 != SET );                                     // wait here for specified time to expire
 446   1      }
 447          
 448          /****************************************************************************************
 449          /*  Microsecond Wait Timer         */
 450          /***********************************/
 451          // returns 2*time_us_div2 + 3 (in uS)....tested and verified
 452          // therefore works for a minimum of 3us (time_us_div2 = 0) or maximum of 513us (time_us_div2 = 0xFF)
 453          // from numbers below, delay = time_us_div2 * (1.25+ 0.25 + 0.5) + 1.25+ 0.25 + 1 + 0.5 = 2*time_us_div2 +
             - 3 (in uS)
 454          
 455          void wait_time_x2us_plus3 (unsigned char time_us_div2)          // 1.25 us to call function
 456          {       
 457   1              while(time_us_div2>0) {                                         // each comparison takes 1.25 uS
 458   2                      time_us_div2--;                                                 // 250ns operation
 459   2              }                                                                                       // 500ns delay to begining of loop
 460   1              _nop_();                                                                        // 250 ns delay to make total delay an integer
 461   1      }                                                                                               // 500 ns to return from function
 462          
 463          /***************************************************************************************/
 464          /* Timer0 Service Routine                       */ 
 465          /****************************************/
 466          // Interrupt occurs every 32ms, always running    -  used for LED blink and polling data
 467          
 468          void timer0_isr (void) interrupt 1 using 3
 469          {
 470   1      //      if(watchdog_count>16)                                           // trigger watchdog if loop hasn't completed in 5 seconds
 471   1      //              { soft_reset();}
 472   1                      
 473   1              ++bcnt;
 474   1              if ( bcnt == BRATE320mS) {
 475   2      //      if ( bcnt >= BRATE1S) {
 476   2              bcnt = 0;
 477   2                      poll_data = SET;                                                // poll data every 320ms
 478   2                      cc_req_320ms++;                                                 // increment count every 320ms
 479   2      //              watchdog_count++;
 480   2         }
 481   1      }
 482          
 483          /***************************************************************************************/
C51 COMPILER V8.04   SCUBA2PS                                                              03/26/2007 13:32:42 PAGE 9   

 484          /* Timer1 Service Routine                       */ 
 485          /****************************************/
 486          // Interrupt occurs every 5ms when enabled       - used for wait_time()
 487          
 488          void timer1_isr (void) interrupt 3 using 3
 489          {
 490   1         --num_T1_ints;                                                               // count the number of interupts
 491   1         if (num_T1_ints == 0) {                                              // check if interrupt time is up
 492   2            TR1=OFF;                                                                  // Stop the timer
 493   2                timeup_T1 = SET;                                                      // Indicate time is up
 494   2         }
 495   1         else {                                                                               // reload timer
 496   2            TL1 = LS_RELOAD_5mS;                                              // interrupts always occur every 5mS
 497   2                TH1 = MS_RELOAD_5mS;
 498   2         }
 499   1      }
 500          
 501          /***************************************************************************************/
 502          /* Timer2 Service Routine                       */ 
 503          /****************************************/
 504          // Interrupt occurs ONLY when external SOFT RESET button pushed
 505          
 506          void timer2_isr (void) interrupt 5 using 0
 507          {
 508   1      //      LED_STATUS = ON;                // used as soft-reset test o/p; on P1-pin3
 509   1              TF2=0;                                                          // clear interrupt
 510   1      //      ET2 = OFF;                                                      // Disable Timer2 Interrupts until back in main loop
 511   1      //      soft_reset();                                           // reset program counter to jump point ( past init() )
 512   1      }
 513          
 514          
 515          /*=============================================================================================*/
 516          // RS232 Serial IO stuff
 517          
 518          #include <ctype.h>
 519          char echo[2] = "\000\000";
 520          
 521          unsigned char idata prt_data_blk[(CC_SPI_BLEN*2)+15];           // ps_data_blk printf output buffer
 522          
 523          /*----->convert a char value to 2 ascii hex char, store results at char *p */
 524          void ByteToHex( unsigned char idata b, char *p)
 525          {
 526   1              unsigned char mask = 0x0f;
 527   1              unsigned char idata c;
 528   1              
 529   1          c = (b>>4) & mask;                  // most signif char first for endian
 530   1              if (c<10) *p++ = ('0'+c);
 531   1              else      *p++ = ('A'+c-10);
 532   1              c = b & mask;
 533   1              if (c<10) *p++ = ('0'+c);
 534   1              else      *p++ = ('A'+c-10);
 535   1      }
 536          
 537          /*-----> print the ps_data_blk[] in hex */
 538          void sio_prt_datablk_hex(void)
 539          {
 540   1              unsigned char i, n;
 541   1                      
 542   1              n=0;
 543   1              prt_data_blk[n++] = '\r';
 544   1              prt_data_blk[n++] = '\r';
 545   1              prt_data_blk[n++] = ' ';
C51 COMPILER V8.04   SCUBA2PS                                                              03/26/2007 13:32:42 PAGE 10  

 546   1              prt_data_blk[n++] = ' ';
 547   1                              
 548   1                      for( i=0 ; i<(CC_SPI_BLEN) ; i++)
 549   1                              {
 550   2                              ByteToHex( ps_data_blk[i], prt_data_blk+n );
 551   2                              n += 2;
 552   2                              }
 553   1              prt_data_blk[n++] = '\r';
 554   1              prt_data_blk[n] = '\000';
 555   1              
 556   1              snd_msg(prt_data_blk);          // 
 557   1      }
 558          
 559          /*-----> print the ps_data_blk[] Temperatures in hex */
 560          void sio_prt_temps_hex(void)
 561          {
 562   1              unsigned char n;
 563   1                      
 564   1              n=0;
 565   1              prt_data_blk[n++] = '\r';
 566   1              prt_data_blk[n++] = '\r';
 567   1              prt_data_blk[n++] = '\t';
 568   1                              
 569   1              ByteToHex( *PSU_TEMP_1, prt_data_blk+n ); n += 2;       // 
 570   1              prt_data_blk[n++] = ' ';
 571   1              ByteToHex( *PSU_TEMP_2, prt_data_blk+n ); n += 2;
 572   1              prt_data_blk[n++] = ' ';
 573   1              ByteToHex( *PSU_TEMP_3, prt_data_blk+n ); n += 2;
 574   1                      
 575   1              prt_data_blk[n++] = '\r';
 576   1              prt_data_blk[n] = '\000';
 577   1              
 578   1              snd_msg(prt_data_blk);          // 
 579   1      }
 580          
 581          // PSU volts and current measurments calibration factors, V/ADU, A/ADU
 582          /**/
 583          #define CF_pVha         (float)0.00335
 584          #define CF_pVa          (float)0.0020723
 585          #define CF_pVlvd        (float)0.001504
 586          #define CF_pVcore       (float)0.0010012
 587          #define CF_nVa          (float)0.002078
 588          // Amp/ADU
 589          #define CF_pIVha        (float)0.00006008
 590          #define CF_pIVa         (float)0.006011
 591          #define CF_pIVlvd       (float)0.0015985
 592          #define CF_pIVcore      (float)0.005203
 593          #define CF_nIVa         (float)0.0007993
 594          #define ushort unsigned short
 595          
 596          /*----->  ItoA assumes an unsigned short that is from a float scaled * 100, to provide a fixed 2 decimal p
             -laces */ 
 597          unsigned char ItoA(unsigned short n, unsigned char *buf)
 598          {
 599   1      unsigned char i;
 600   1       
 601   1              // only/always 5 char: 2 digits, a '.' 2 more digits , plus a terminating NULL
 602   1              // done in reverse order, starting with a NULL, then the LSD, so [4-i] as the index
 603   1           buf[5]=0;
 604   1           for(i=0; i<5; i++){
 605   2                      if( i == 2) buf[4-i] = '.';
 606   2                      else {
C51 COMPILER V8.04   SCUBA2PS                                                              03/26/2007 13:32:42 PAGE 11  

 607   3                              buf[4-i] = (n%10)+48;   // take the remainer of a div by 10, convert to ascii
 608   3                              n/=10;
 609   3                      }
 610   2          }
 611   1              return 5;
 612   1       }
 613          
 614          /*-----> output the sensed & converted PSU current values from the data block */
 615          void sio_prt_currents(void)
 616          {
 617   1              ushort i;
 618   1              unsigned char n;
 619   1                      
 620   1              n=0;
 621   1              prt_data_blk[n++] = '\r';
 622   1              prt_data_blk[n++] = '\r';
 623   1              prt_data_blk[n++] = '\t';
 624   1              
 625   1              i = *(ushort*)I_VCORE;                          // +3.0
 626   1              i = (ushort)((float)i * CF_pIVcore * 100);              // convert to 'real' value, * 100 for 2 decimal places
 627   1              n += ItoA( i, prt_data_blk+n );         
 628   1              prt_data_blk[n++] = ' ';                        // insert a space between values
 629   1              i = *(ushort*)I_VLVD;                           // +4.5
 630   1              i = (ushort)((float)i * CF_pIVlvd * 100);       
 631   1              n += ItoA( i, prt_data_blk+n );         
 632   1              prt_data_blk[n++] = ' ';
 633   1              i = *(ushort*)I_VAH;                            // +10.0
 634   1              i = (ushort)((float)i * CF_pIVha * 100);
 635   1              n += ItoA( i, prt_data_blk+n );         
 636   1              prt_data_blk[n++] = ' ';
 637   1              i = *(ushort*)I_VA_PLUS;                        // +6.2
 638   1              i = (ushort)((float)i * CF_pIVa * 100); 
 639   1              n += ItoA( i, prt_data_blk+n );         
 640   1              prt_data_blk[n++] = ' ';
 641   1              prt_data_blk[n++] = '-';                        // next value is from negative supply, so insert a '-'
 642   1              i = *(ushort*)I_VA_MINUS;                       // -6.2
 643   1              i = (ushort)((float)i * CF_nIVa * 100); 
 644   1              n += ItoA( i, prt_data_blk+n );         
 645   1      
 646   1              prt_data_blk[n++] = '\r';
 647   1              prt_data_blk[n] = '\000';
 648   1              snd_msg(prt_data_blk);          // 
 649   1      }
 650          
 651          
 652          /*-----> output the sensed & converted PSU voltage values from the data block */
 653          void sio_prt_volts(void)
 654          {
 655   1              ushort v;
 656   1              unsigned char n;
 657   1                      
 658   1              n=0;
 659   1              prt_data_blk[n++] = '\r';
 660   1              prt_data_blk[n++] = '\r';
 661   1              prt_data_blk[n++] = '\t';
 662   1              
 663   1              v = *(ushort*)V_VCORE;                          // +3.0
 664   1              v = (ushort)((float)v * CF_pVcore * 100);               // convert to 'real' value, * 100 for 2 decimal places
 665   1              n += ItoA( v, prt_data_blk+n );         
 666   1              prt_data_blk[n++] = ' ';
 667   1              v = *(ushort*)V_VLVD;                           // +4.5
 668   1              v = (ushort)((float)v * CF_pVlvd * 100);        
C51 COMPILER V8.04   SCUBA2PS                                                              03/26/2007 13:32:42 PAGE 12  

 669   1              n += ItoA( v, prt_data_blk+n );         
 670   1              prt_data_blk[n++] = ' ';
 671   1              v = *(ushort*)V_VAH;                            // +10.0
 672   1              v = (ushort)((float)v * CF_pVha * 100);
 673   1              n += ItoA( v, prt_data_blk+n );         
 674   1              prt_data_blk[n++] = ' ';
 675   1              v = *(ushort*)V_VA_PLUS;                        // +6.2
 676   1              v = (ushort)((float)v * CF_pVa * 100);  
 677   1              n += ItoA( v, prt_data_blk+n );         
 678   1              prt_data_blk[n++] = ' ';
 679   1              prt_data_blk[n++] = '-';
 680   1              v = *(ushort*)V_VA_MINUS;                       // -6.2
 681   1              v = (ushort)((float)v * CF_nVa * 100);  
 682   1              n += ItoA( v, prt_data_blk+n );         
 683   1      
 684   1              prt_data_blk[n++] = '\r';
 685   1              prt_data_blk[n] = '\000';
 686   1              snd_msg(prt_data_blk);          // 
 687   1      }
 688          
 689          
 690          /***************************************************************************************/
 691          /* Send Serial Message     */ 
 692          /***************************/
 693          
 694          void snd_msg (char *message)
 695          {
 696   1      
 697   1              while( msg_ptr != 0 ) ;                         //if currently sending wait for it to end.
 698   1              msg_ptr = message;
 699   1              TI = SET;                                                       // Generates SIO interrupt
 700   1      }
 701          
 702          /***************************************************************************************/
 703          /* Serial Interrupt Service Routine     */ 
 704          /****************************************/
 705          // Interrupt driven serial I/O
 706          
 707          //void serial_isr (void) interrupt 4 using 2
 708          void serial_isr (void) interrupt 4 using 1      // changed to 'using 1' RHJ
 709          {
 710   1              char c;
 711   1              
 712   1              // Transmitted Data Interrupt
 713   1              if ( TI == SET ) {                              
 714   2              TI = CLEAR;                                                             // Clears TI Interrupt
 715   2                      c = *msg_ptr;
 716   2                      if (c != NULL) {                                                // If message not NULL, load into transmission buffer 
 717   3                      ++msg_ptr;
 718   3                              SBUF = c;       
 719   3                      }
 720   2                      else msg_ptr = 0;
 721   2              }       
 722   1         
 723   1              // Received Data Interrupt
 724   1              if ( RI == SET ) {                                      
 725   2              RI = CLEAR;                                                     // Clears RI Interrupt
 726   2                      c = SBUF;                                                       // get the rcved char
 727   2                      if(isprint(c))                                          // if isprint, echo it,
 728   2                              {
 729   3                              echo[0]  = c;
 730   3                              msg_ptr = echo;                 
C51 COMPILER V8.04   SCUBA2PS                                                              03/26/2007 13:32:42 PAGE 13  

 731   3                              TI = SET;                                               //  TI Interrupt to tx
 732   3                              sio_rxbuf[sio_rx_idx++] = c;    // and add it to the rxbuf
 733   3                              }
 734   2                      if (sio_rx_idx >= (BUF_SIZE-1))         // *****these three lines are suspect, need to fix
 735   2                      --sio_rx_idx;                                   // if rcved string is too long go back and maybe overwrite
 736   2                              
 737   2                      if (c == '\r') {                                        // CR indicates end of message
 738   3                      sio_rx_idx = 0;                                 // 
 739   3                      sio_msg_complete = SET;                 // Indicate entire message received
 740   3                      }
 741   2              }   
 742   1      }
 743          
 744          /*=============================================================================================*/
 745          
 746          /***************************************************************************************/
 747          /* SPI Interrupt Service Routine     */ 
 748          /*************************************/
 749          // read and clear spi status register
 750          
 751          void spi_isr (void) interrupt 9 using 2         // added 'using 2' RHJ
 752          {
 753   1              switch( SPSTA )                                 
 754   1              {
 755   2                      // SPIF flag set --> transmission complete
 756   2                      case 0x80:                                                              
 757   2                      rcv_spi_blk[spi_idx] = SPDAT;           // read receive data
 758   2                              spi_complete = 1;                                       // indicate transaction finished
 759   2                              break;
 760   2      
 761   2                      /* error cases -> refer to pg. 96 in AT89 datasheet */
 762   2                      // mode fault
 763   2                      case 0x10:                                                      
 764   2                      // this does not apply as single master on SPI bus and SSDisable bit set in SPSTA register                                      
             -                                                                                                                                
 765   2                              break;
 766   2              
 767   2                      // write collision
 768   2                      case 0x40:                                                      
 769   2                      // write collision does NOT cause an interrupt therefore this should be elsewhere if needed
 770   2                              // currently ONLY the function send_psu_data_block() ever writes to SPDAT so write collision not possib
             -le                                                                                                         
 771   2                              break;
 772   2      
 773   2                      default:
 774   2                              break;
 775   2              }
 776   1      }
 777                          
 778          /***************************************************************************************/
 779          /* Retrieve Data Block       */ 
 780          /*****************************/  
 781          //Updates PSU Data Block with Current Values
 782          
 783          void update_data_block (void)
 784          {
 785   1              // Fan Speeds
 786   1              // get_fan_speeds();                                                                            // not implemented
 787   1      
 788   1              // DS18S20 - Temperatures - read only if present
 789   1              ds_get_temperature(PSUC_DS18S20, PSU_TEMP_1);                           // always read PSUC DS = temperature 1
 790   1              
C51 COMPILER V8.04   SCUBA2PS                                                              03/26/2007 13:32:42 PAGE 14  

 791   1              if (temp1_present)
 792   1                      ds_get_temperature(PSU_DS18S20, PSU_TEMP_2);                    // temperature 2 
 793   1              
 794   1              if (temp3_present)
 795   1                      ds_get_temperature(DTEMP2_ID, PSU_TEMP_3);                              // temperature 3
 796   1      
 797   1              /*** ADC - Voltage and Current Readings - refer to documentation ***/
 798   1              // Ground reading scaled to 2mV per division (+/- 2.047V range)
 799   1              //read_adc(ADC_CH5, ADC_BI_5V, VOLTAGE, ADC_OFFSET);                    // Grounded ADC input channel reading (bipolar)
 800   1              
 801   1              // Voltages scaled to ~61% of nominal values, unipolar
 802   1              read_adc(ADC_CH0, ADC_UNI_10V, VOLTAGE, V_VCORE);                       // +Vcore supply scaled
 803   1              read_adc(ADC_CH1, ADC_UNI_10V, VOLTAGE, V_VLVD);                        // +Vlvd supply scaled
 804   1              read_adc(ADC_CH2, ADC_UNI_10V, VOLTAGE, V_VAH);                         // +Vah supply scaled
 805   1              read_adc(ADC_CH3, ADC_UNI_10V, VOLTAGE, V_VA_PLUS);                     // +Va supply scaled
 806   1              read_adc(ADC_CH4, ADC_UNI_10V, VOLTAGE, V_VA_MINUS);            // -Va supply scaled
 807   1      
 808   1              // Currents scaled to ~73% of nominal values, unipolar
 809   1              read_adc(ADC_CH0, ADC_UNI_10V, CURRENT, I_VCORE);                       // Current +Vcore supply
 810   1              read_adc(ADC_CH1, ADC_UNI_10V, CURRENT, I_VLVD);                        // Current +Vlvd supply
 811   1              read_adc(ADC_CH2, ADC_UNI_10V, CURRENT, I_VAH);                         // Current +Vah supply
 812   1              read_adc(ADC_CH3, ADC_UNI_10V, CURRENT, I_VA_PLUS);                     // Current +Va supply
 813   1              read_adc(ADC_CH4, ADC_UNI_10V, CURRENT, I_VA_MINUS);            // Current -Va supply    
 814   1              
 815   1              // release SCLK
 816   1              SCLK = 1;                                                                                                        //**needed for SPI in send_psu_data_block to work**                                                                                                                                                                            
 817   1              
 818   1              // Bookkeeping 
 819   1                      //Status Word currently not used (initialized to 0)
 820   1              // *STATUS_WORD = 0;                                                                            // undefined status word - higher byte
 821   1              // *(STATUS_WORD+1) = 0;                                                                        // undefined status word - lower byte
 822   1              
 823   1              // Check Digit pre-Calculation
 824   1              check_digit();                                                                                          // updates running checksum total - done here for quick response in send_data_b
             -lock()
 825   1      }
 826          
 827          /***************************************************************************************/
 828          /* Generate Check Digit    */ 
 829          /***************************/
 830          // Implemented as checksum for now to optimize calculation speed (tradeoff for sub-optimal error detection
             -)
 831          // Checksum byte totals 0 when summed with the other 35 bytes in the PSU data block  (ignoring addition ov
             -erflow)
 832          // *** This function calculated total of first 34 bytes in checksum
 833          // *** Finish checksum calculation and set in data block using COMPLETE_CHECKSUM macro (**AFTER** ACK/NAK 
             -byte has been set)
 834           
 835          void check_digit (void)
 836          {
 837   1              int j;
 838   1              running_checksum = 0;                                                                           // reset checksum
 839   1              for(j = 0; j < ACK_BYTE_POS; j++) {                                                     // sum PSU data block up to ACK/NAK byte
 840   2                      running_checksum += ps_data_blk[j];
 841   2              }
 842   1      }
 843          
 844          /***************************************************************************************/
 845          /* Parse Command Received from CC    */ 
 846          /*************************************/
 847          // could to make this more robust - varying degrees of complexity in how to implement this
 848          // current protocol receives 3 2-byte command in first 6 bytes of PSU Data Block transaction
C51 COMPILER V8.04   SCUBA2PS                                                              03/26/2007 13:32:42 PAGE 15  

 849          
 850          void parse_command(void)                 
 851          {
 852   1              //assume commands are in first 6 bytes of received SPI block, ordered and repeated thrice
 853   1              if ( commands_match(rcv_spi_blk, rcv_spi_blk+2,rcv_spi_blk+4) && command_valid(rcv_spi_blk) ) { 
 854   2                      cc_command = rcv_spi_blk;       
 855   2      //              *ACK_NAK = ACK;                                                                                 // ACK command if valid command received in triplicate  
 856   2              }       
 857   1              
 858   1              else {
 859   2                      cc_command = NULL;                                                                              // else NAK command
 860   2      //              *ACK_NAK = NAK;
 861   2              }
 862   1      }
 863          
 864          /***************************************************************************************/
 865          /* Matching Commands Check    */ 
 866          /******************************/
 867          // returns true if three matching commands sent else false
 868          
 869          bit commands_match (char *com_ptr_1, char *com_ptr_2, char *com_ptr_3)
 870          {
 871   1              if( (*com_ptr_1 == *com_ptr_2) && (*(com_ptr_1 + 1) == *(com_ptr_2 + 1)) ) {    // first two commands match
 872   2                      
 873   2                      if( (*com_ptr_1 == *com_ptr_3) && (*(com_ptr_1 + 1) == *(com_ptr_3 + 1)) )      // third command matches
 874   2                              return TRUE;
 875   2                      else
 876   2                              return FALSE;
 877   2              }
 878   1              
 879   1              else
 880   1                      return FALSE;
 881   1      }
 882          
 883          /***************************************************************************************/
 884          /* Valid Command Check    */ 
 885          /****************************************/
 886          // returns true if command received is valid
 887          
 888          bit command_valid (char *com_ptr)
 889          {
 890   1              // If command is valid return TRUE
 891   1              if( (*com_ptr == 0) && (*(com_ptr+1) == 0) )                            // Request Status Command (default)
 892   1                      return TRUE;
 893   1              else if( (*com_ptr == 'C') && (*(com_ptr+1) == 'P') )           // Cycle Power Command
 894   1                      return TRUE;
 895   1              else if( (*com_ptr == 'R') && (*(com_ptr+1) == 'M') )           // Reset MCE Command
 896   1                      return TRUE;
 897   1              else if( (*com_ptr == 'T') && (*(com_ptr+1) == 'O') )           // Turn Off Command
 898   1                      return TRUE;    
 899   1              else
 900   1                      return FALSE;
 901   1      }
 902          
 903          
 904          
C51 COMPILER V8.04   SCUBA2PS                                                              03/26/2007 13:32:42 PAGE 16  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


P0 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0080H  1
msg_ptr. . . . . . . . . . . . . . . .  PUBLIC   PDATA  PTR      0000H  3
P1 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0090H  1
_ByteToHex . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0009H  -----
  b. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
  p. . . . . . . . . . . . . . . . . .  AUTO     PDATA  PTR      0000H  3
  mask . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0006H  1
  c. . . . . . . . . . . . . . . . . .  AUTO     IDATA  U_CHAR   0000H  1
P2 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A0H  1
P3 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B0H  1
P4 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C0H  1
timer0_isr . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
SPCON. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C3H  1
timer1_isr . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
EA . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00AFH  1
timer2_isr . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
command_lsb. . . . . . . . . . . . . .  ABSBIT   -----  BIT      0000H  1
ds_write_bit . . . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
  com_bit. . . . . . . . . . . . . . .  AUTO     DATA   BIT      0000H  1
CS_IADC. . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0091H  1
cc_command . . . . . . . . . . . . . .  PUBLIC   PDATA  PTR      0003H  3
spi_complete . . . . . . . . . . . . .  PUBLIC   DATA   BIT      0000H  1
SPSTA. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C4H  1
IEN0 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A8H  1
_isprint . . . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
IEN1 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B1H  1
_ds_get_temperature. . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  mask . . . . . . . . . . . . . . . .  * REG *  DATA   CHAR     0007H  1
  target . . . . . . . . . . . . . . .  AUTO     PDATA  PTR      0000H  3
  value. . . . . . . . . . . . . . . .  AUTO     PDATA  U_CHAR   0003H  1
  sign . . . . . . . . . . . . . . . .  AUTO     PDATA  U_CHAR   0004H  1
size_t . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_INT    -----  2
rcv_spi_blk. . . . . . . . . . . . . .  PUBLIC   IDATA  ARRAY    0000H  36
CS_VADC. . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B2H  1
IPL0 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B8H  1
nCORE_ON . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A7H  1
ES . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00ACH  1
_wait_time_x2us_plus3. . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  time_us_div2 . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
RI . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0098H  1
sequence_on. . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
LED_STATUS . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B7H  1
TI . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0099H  1
command_bit_adr. . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0000H  1
CKCON0 . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008FH  1
echo . . . . . . . . . . . . . . . . .  PUBLIC   PDATA  ARRAY    0006H  2
sio_prt_volts. . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  v. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0006H  2
  n. . . . . . . . . . . . . . . . . .  AUTO     PDATA  U_CHAR   0000H  1
PT0L . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B9H  1
RCAP2H . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CBH  1
cycle_power. . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
CCON . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D8H  1
prompt . . . . . . . . . . . . . . . .  PUBLIC   CODE   ARRAY    0008H  7
adc_data . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0001H  1
RCAP2L . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CAH  1
main . . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
C51 COMPILER V8.04   SCUBA2PS                                                              03/26/2007 13:32:42 PAGE 17  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


_read_adc. . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0006H  -----
  chan . . . . . . . . . . . . . . . .  AUTO     DATA   CHAR     0007H  1
  mode . . . . . . . . . . . . . . . .  AUTO     DATA   CHAR     0005H  1
  adc_sel. . . . . . . . . . . . . . .  AUTO     DATA   BIT      0000H  1
  target . . . . . . . . . . . . . . .  AUTO     PDATA  PTR      0002H  3
  bit_cnt. . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0005H  1
  temp_char_ptr. . . . . . . . . . . .  AUTO     PDATA  PTR      0005H  3
  adc_reading. . . . . . . . . . . . .  AUTO     PDATA  U_INT    0008H  2
bcnt . . . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0000H  1
CCSS . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0094H  1
SCLK . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0096H  1
PCON . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0087H  1
SBUF . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0099H  1
serial_isr . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  c. . . . . . . . . . . . . . . . . .  AUTO     PDATA  CHAR     0000H  1
LED_FAULT. . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B5H  1
SCON . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0098H  1
sio_msg_complete . . . . . . . . . . .  PUBLIC   DATA   BIT      0001H  1
TMOD . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0089H  1
TCON . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0088H  1
poll_data. . . . . . . . . . . . . . .  PUBLIC   DATA   BIT      0002H  1
init . . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  i. . . . . . . . . . . . . . . . . .  * REG *  DATA   INT      0006H  2
LEDCON . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F1H  1
sio_prt_temps_hex. . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  n. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0004H  1
MOSI . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0097H  1
MISO . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0095H  1
BDRCON . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   009BH  1
BRST . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A0H  1
SREQ . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0093H  1
running_checksum . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0001H  1
sio_rx_idx . . . . . . . . . . . . . .  PUBLIC   DATA   CHAR     0002H  1
adr_mask . . . . . . . . . . . . . . .  PUBLIC   PDATA  U_CHAR   0008H  1
cc_req_320ms . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0003H  1
_commands_match. . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  com_ptr_1. . . . . . . . . . . . . .  AUTO     PDATA  PTR      0000H  3
  com_ptr_2. . . . . . . . . . . . . .  AUTO     PDATA  PTR      0003H  3
  com_ptr_3. . . . . . . . . . . . . .  AUTO     PDATA  PTR      0006H  3
_wait_time . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0004H  -----
  loops. . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0006H  2
ET0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A9H  1
read_bus . . . . . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
ET1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00ABH  1
TF2. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00CFH  1
TH0. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008CH  1
LED_OUTON. . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B6H  1
TH1. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008DH  1
ADC_MS_DBIT. . . . . . . . . . . . . .  ABSBIT   -----  BIT      000FH  1
TH2. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CDH  1
temp1_present. . . . . . . . . . . . .  PUBLIC   DATA   BIT      0003H  1
TL0. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008AH  1
temp2_present. . . . . . . . . . . . .  PUBLIC   DATA   BIT      0004H  1
TL1. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008BH  1
temp3_present. . . . . . . . . . . . .  PUBLIC   DATA   BIT      0005H  1
send_psu_data_block. . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
TL2. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CCH  1
C51 COMPILER V8.04   SCUBA2PS                                                              03/26/2007 13:32:42 PAGE 18  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


TR0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      008CH  1
sio_rxbuf. . . . . . . . . . . . . . .  PUBLIC   IDATA  ARRAY    0024H  10
_command_valid . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  com_ptr. . . . . . . . . . . . . . .  * REG *  DATA   PTR      0001H  3
UEPINT . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F8H  1
TR1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      008EH  1
num_T1_ints. . . . . . . . . . . . . .  PUBLIC   DATA   U_INT    0004H  2
TR2. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00CAH  1
reset_MCE. . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
ds_reset . . . . . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
  presence . . . . . . . . . . . . . .  AUTO     DATA   BIT      0000H  1
BRL. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   009AH  1
sio_prt_currents . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  i. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0006H  2
  n. . . . . . . . . . . . . . . . . .  AUTO     PDATA  U_CHAR   0000H  1
parse_command. . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
watchdog_count . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0006H  1
sio_prt_datablk_hex. . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  i. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0004H  1
  n. . . . . . . . . . . . . . . . . .  AUTO     PDATA  U_CHAR   0000H  1
nPSU_ON. . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A1H  1
T2CON. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C8H  1
ds_read_byte . . . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
  b. . . . . . . . . . . . . . . . . .  AUTO     PDATA  INT      0000H  2
  read_temp. . . . . . . . . . . . . .  AUTO     PDATA  U_CHAR   0002H  1
_ItoA. . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0013H  -----
  n. . . . . . . . . . . . . . . . . .  AUTO     PDATA  U_INT    0000H  2
  buf. . . . . . . . . . . . . . . . .  AUTO     PDATA  PTR      0002H  3
  i. . . . . . . . . . . . . . . . . .  AUTO     PDATA  U_CHAR   0005H  1
prt_data_blk . . . . . . . . . . . . .  PUBLIC   IDATA  ARRAY    002EH  87
_snd_msg . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0006H  -----
  message. . . . . . . . . . . . . . .  AUTO     PDATA  PTR      0000H  3
_ds_initialize . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  mask . . . . . . . . . . . . . . . .  * REG *  DATA   CHAR     0007H  1
  present. . . . . . . . . . . . . . .  AUTO     DATA   BIT      0000H  1
update_data_block. . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
ds_convert_T . . . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
software_version_byte. . . . . . . . .  PUBLIC   CODE   CHAR     0007H  1
_ds_get_4byte_id . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  mask . . . . . . . . . . . . . . . .  * REG *  DATA   CHAR     0007H  1
  target . . . . . . . . . . . . . . .  AUTO     PDATA  PTR      0000H  3
  presence_detect. . . . . . . . . . .  AUTO     DATA   BIT      0000H  1
  family_code. . . . . . . . . . . . .  AUTO     PDATA  U_CHAR   0003H  1
  serial_number. . . . . . . . . . . .  AUTO     PDATA  ARRAY    0004H  6
  crc_code . . . . . . . . . . . . . .  AUTO     PDATA  U_CHAR   000AH  1
helpmsg. . . . . . . . . . . . . . . .  PUBLIC   CODE   ARRAY    000FH  183
cc_spi . . . . . . . . . . . . . . . .  PUBLIC   DATA   BIT      0006H  1
spi_idx. . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0007H  1
check_digit. . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  j. . . . . . . . . . . . . . . . . .  * REG *  DATA   INT      0006H  2
ds_read_bit. . . . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
  temp_bit . . . . . . . . . . . . . .  AUTO     DATA   BIT      0000H  1
ps_data_blk. . . . . . . . . . . . . .  PUBLIC   IDATA  ARRAY    0085H  36
sequence_off . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
spi_isr. . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
timeup_T1. . . . . . . . . . . . . . .  PUBLIC   DATA   BIT      0007H  1
_ds_write_byte . . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
C51 COMPILER V8.04   SCUBA2PS                                                              03/26/2007 13:32:42 PAGE 19  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


  command. . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
  a. . . . . . . . . . . . . . . . . .  AUTO     PDATA  INT      0000H  2
SPDAT. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C5H  1


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3156    ----
   CONSTANT SIZE    =    198    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =      9      56
   DATA SIZE        =     10    ----
   IDATA SIZE       =    169       1
   BIT SIZE         =      8       6
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
