C51 COMPILER V8.02   SCUBA2PS                                                              01/23/2009 15:39:15 PAGE 1   


C51 COMPILER V8.02, COMPILATION OF MODULE SCUBA2PS
OBJECT MODULE PLACED IN .\output\SCUBA2PS.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE SCUBA2PS.C COMPACT ROM(COMPACT) MODP2 DEBUG OBJECTEXTEND PRINT(.\output\SCU
                    -BA2PS.lst) OBJECT(.\output\SCUBA2PS.obj)

line level    source

   1          /************************************************************************************/
   2          /*      Scuba 2 Power Supply Controller - SC2_ELE_S565_102D
   3                          Tom Felton - Feb 22, 2006
   4                          Stuart Hadfield - July/August 2006               
   5          /************************************************************************************/
   6          // Revision history: 
   7          // $Log: scuba2ps.c,v $
   8          //
   9          //
  10          // Version 4.0 13-January-2009 RL
  11          // Adds 12V rail voltage reading to CC request and to serial terminal output
  12          // V_12VRAIL added to Data Block Byte #5 - formerly Fan1 Tachometer
  13          // I_12VRail added to Data Block Byte #6 - formerly Fan2 Tachometer
  14          // read_adc function modified to accomodate size of data within the data packet -- 1 byte size or 2 bytes 
             -size
  15          //
  16          // Adds Hex serial output for voltage and current
  17          //
  18          // Version 3.2 22-March-2007 RHJ
  19          //
  20          // Version 3.1 15-March-2007 RHJ
  21          //
  22          // Revision 1.13  2006/12/23 00:39:00  stuartah
  23          // Version 2.3 Release
  24          //
  25          // Revision 1.12  2006/11/22 00:10:08  stuartah
  26          // Fixed FAULT LED behavior to turn on if no CC request for over a minute (no longer flashes)
  27          //
  28          // Revision 1.11  2006/11/21 23:30:40  stuartah
  29          // Added soft_reset assembly code, triggered via external button (timer2 input)
  30          //
  31          // Revision 1.10  2006/11/21 21:25:41  stuartah
  32          // Implemented Timer2 as external interrupt
  33          //
  34          // Revision 1.9  2006/11/20 23:22:00  stuartah
  35          // Cleaned code, improved commenting, implemented changes for PSUC rev. G
  36          //
  37          // Revision 1.8  2006/10/03 07:38:34  stuartah
  38          // Added presence detection of DS18S20s
  39          //
  40          // Revision 1.7  2006/10/03 05:59:12  stuartah
  41          // Tested in Subrack, Basic Command working
  42          //
  43          // Revision 1.6  2006/09/07 20:37:01  stuartah
  44          // Cleaned up init() and re-organized main loop structure
  45          //
  46          // Revision 1.5  2006/09/05 20:06:20  stuartah
  47          // Changed i2c.c to MAX1271.c (code for interfacing ADCs, does not use i2c protocol)
  48          //
  49          // Revision 1.4  2006/08/31 19:30:38  stuartah
  50          // Added functionality for measuring fan speeds
  51          //
  52          // Revision 1.3  2006/08/30 19:54:19  stuartah
  53          // Implemented checksum
C51 COMPILER V8.02   SCUBA2PS                                                              01/23/2009 15:39:15 PAGE 2   

  54          //
  55          // Revision 1.2  2006/08/29 21:06:06  stuartah
  56          // Initial CVS Build - Most Basic Functionality Implemented
  57          //      
  58          /********************************************************************************       
  59          Refer to the following Data Sheets:
  60                          Processor - Atmel AT89C5131AM
  61                          Temperature Monitoring & Silicon ID - Dallas DS18S20-PAR
  62                          ADC for Power Supply Voltage Monitoring - Maxim MAX1270ACAI
  63                          EEPROM non-volatile memory - Atmel AT25128A
  64          
  65                  NOTE: THIS PROGRAM IS NO WHERE NEAR COMPLETE OR TESTED
  66                  The I/O pins are set correctly for this version (revF).
  67          *********************************************************************************/
  68          
  69          /**********     Version 2.2     *****************
  70          Polling and communication functionality seems to be working     */
  71          
  72          
  73          // Header File containing function prototypes and global variable declarations
  74          #include "scuba2ps.h"
*** WARNING C182 IN LINE 114 OF MAX1271.C: pointer to different objects
*** WARNING C182 IN LINE 122 OF MAX1271.C: pointer to different objects
  75          
  76          // Constant Variables
  77          char code software_version_byte = 0x40;                                         // 1 byte Software Version 
  78          char code prompt[] =  "\rPSC> ";                                                        // RS232 IO prompt
  79          
  80          // Software Version and Help List of Commands Serial Message
  81          char code helpmsg[] = "\r\r\tPSUC v4.0\r\
  82          \t?  This stuff.\r\
  83          \tc  Cycle Power.\r\
  84          \tf  Turn PSU off.\r\
  85          \tn  Turn PSU on.\r\
  86          \tr  Reset MCE BSRT.\r\
  87          \td  PSU data block.\r\
  88          \tt  Temperatures in hex.\r\
  89          \tv  PSU voltages.\r\
  90          \tb  PSU voltages in hex.\r\
  91          \ti  PSU currents.\r\
  92          \to  PSU currents in hex.\r";
  93          //
  94          
  95          /****************************************************************************************
  96           *  Main Program                           *
  97           *************************** */
  98          
  99          main() 
 100          { 
 101   1              // Initialize Hardware and Software Variables
 102   1              init();                                                                                 
 103   1              
 104   1              // Output Version + Help on Serial Port
 105   1              snd_msg(helpmsg);
 106   1                      
 107   1              // Initial Power-Up
 108   1              sequence_on();                          
 109   1              
 110   1      //      _nop_();        // << THIS IS THE SOFT_RESET JUMP-TO POINT      
 111   1      //      if( ET2 == 0) snd_msg("\rRestarting\r");        
 112   1      //      LED_STATUS = OFF;               // used as soft-reset test o/p; on P1-pin3
 113   1      //      wait_time( 600 );                       // wait 3 seconds for button release and any bounces
C51 COMPILER V8.02   SCUBA2PS                                                              01/23/2009 15:39:15 PAGE 3   

 114   1      //      TF2 = 0;                                        // clear any interrupt
 115   1      //      ET2 = 1;                                        // Enable Timer2 soft_reset Interrupts
 116   1              
 117   1              snd_msg(prompt);
 118   1                
 119   1              /***  Main Loop - Periodically update PSU data block, respond to Clock Card / RS232 Commands  ***/
 120   1              while(TRUE) {                                                           
 121   2      
 122   2                      // Serial I/O message ready to parse
 123   2                      if ( sio_msg_complete == SET ) {
 124   3                              ES = 0;                                         // Disable SIO Interrupts                                       
 125   3                      sio_msg_complete = CLEAR;
 126   3                              sio_rx_idx = 0;                         // reset message pointer
 127   3                              switch ( sio_rxbuf[0] ) {       // parse message
 128   4                                      case 'c':                               // Cycle Power Command
 129   4                                              cycle_power();
 130   4                                              break;
 131   4                                              
 132   4                                      case 'r':                               // Reset MCE Command
 133   4                                              reset_MCE();
 134   4                                              break;
 135   4      
 136   4                                      case '?':                               // Respond with Software Version
 137   4                                              snd_msg(helpmsg);       // and a help list of commands
 138   4                                              break;
 139   4      
 140   4                                      case 'd':                               // Respond with PSU data block          
 141   4                                              sio_prt_datablk_hex();
 142   4                                              break;                                  
 143   4                        
 144   4                                      case 't':                               // Respond with PSU data block temperatures             
 145   4                                              sio_prt_temps_hex();
 146   4                                              break;
 147   4                                                                                      
 148   4                                      case 'f':                               // Turn Off Command
 149   4                                              sequence_off();
 150   4                                              break;
 151   4                                              
 152   4                                      case 'n':                               // Turn On Command
 153   4                                              sequence_on();
 154   4                                              break;
 155   4                                              
 156   4                                      case 'i':                               // output PSU voltages          
 157   4                                              sio_prt_currents() ;
 158   4                                              break;                                  
 159   4      
 160   4                                      case 'v':                               // output PSU voltages          
 161   4                                              sio_prt_volts() ;
 162   4                                              break;
 163   4                                      case 'b':               // output PSU voltages in hex
 164   4                                              sio_prt_volts_hex() ;
 165   4                                              break;                                  
 166   4      
 167   4                                      case 'o':               // output PSU voltages in hex
 168   4                                              sio_prt_current_hex();
 169   4                                              break;
 170   4      
 171   4                                      default:
 172   4                                              snd_msg("\tWHAT?");
 173   4                                              break;
 174   4                              }
 175   3                              sio_rxbuf[0] = 0;
C51 COMPILER V8.02   SCUBA2PS                                                              01/23/2009 15:39:15 PAGE 4   

 176   3                              ES = 1;                                         // Enable SIO Interrupts
 177   3                              snd_msg(prompt);
 178   3                      }
 179   2      
 180   2                      // Listen for data request from clock card
 181   2                      cc_spi = ~SREQ;                                                                 // SREQ active low
 182   2      
 183   2                      // Time to re-poll data
 184   2                      if ( poll_data == SET ) {                                               // polling rate ~ 3Hz, CC Request Rate ~ 0.5Hz                  
 185   3                              update_data_block();
 186   3                              poll_data = CLEAR;                                                      // Data Poll Complete
 187   3                              *DATABLK_UPDATED = TRUE;                                                // flag that data_blk has been updated                                                                                                                  
 188   3                      }
 189   2                      
 190   2                      // Send data block if it has been requested
 191   2                      if ( cc_spi == TRUE) {                                     
 192   3                              cc_req_320ms = 0;                                                       // Reset count since last CC request
 193   3                              LED_FAULT = 0;                                                          // Turn Off LED if on
 194   3                              send_psu_data_block();                                          // Time to send SPI Data to Clock Card
 195   3                              cc_spi = FALSE;                                                         // Data Block Transmission Complete
 196   3                              *DATABLK_UPDATED = FALSE;                                       // flag that data_blk info is 'old'
 197   3                      }
 198   2              
 199   2                      // Act on command from Clock Card
 200   2                      if ( cc_command != NULL )               
 201   2                              switch ( *cc_command ) {                                        // parse received command       
 202   3                                      
 203   3                                      case 'C':                                                               // Cycle Power Command
 204   3                                              cycle_power();
 205   3                                              cc_command = NULL;
 206   3                                              break;
 207   3                                      
 208   3                                      case 'R':                                                               // Reset MCE Command
 209   3                                              reset_MCE();
 210   3                                              cc_command = NULL;
 211   3                                              break;
 212   3      
 213   3                                      case 'T':                                                               // Turn Off Command
 214   3                                              sequence_off();
 215   3                                              cc_command = NULL;
 216   3                                              break;
 217   3      
 218   3                              default:                                                                // Status Request or erroneous command.  Difference is ACK/NAK.
 219   3                                              cc_command = NULL;
 220   3                                              break;  
 221   3                      }
 222   2      
 223   2                      // Loop Maintenance                     
 224   2                      if (cc_req_320ms > 187) {                                               // if its been more than a minute since last CC request, 187*320ms = 
 225   3                                      LED_FAULT = 1;                                                  // then turn on fault LED
 226   3                      }
 227   2      
 228   2                      watchdog_count = 0;                                                             // clear watchdog counter
 229   2      
 230   2              }
 231   1      }
 232          
 233          /****************************************************************************************
 234           *  Initialize                     *
 235           *************************** */
 236          
 237          void init(void)
C51 COMPILER V8.02   SCUBA2PS                                                              01/23/2009 15:39:15 PAGE 5   

 238          {
 239   1              int i = 0;                                      // temporary index variable
 240   1      
 241   1      /**************         Hardware Setup          **************/
 242   1              // Set all input ports for input and output ports to default values     -- see schematic and io.h
 243   1              // IO Port Setup  --  1=Input(or Special Function), 0=Output
 244   1              P0 = 0x66;              //0110 0110             //****** changed to acomidate SSTRB lines in Rev G ******
 245   1              //P0 = 0x60;    //0110 0000
 246   1              P1 = 0xff;              //1111 1111
 247   1              P2 = 0xbe;              //1011 1110             // Intialize PSU OFF
 248   1              P3 = 0xdf;              //1101 1111
 249   1      
 250   1              /* SPI setup                            -- these declarations are redundant.  done in port settings above                               
 251   1              CS_EEPROM = 1;                          // CableSelect lines active low 
 252   1              CS_VADC = 1;
 253   1              CS_IADC = 1;
 254   1              CCSS=1;
 255   1              //SREQ = 0;                                     // SREQ active low but this is needed to not overload buffer U5 - PROTOTYPE PSUC REV F ON
             -LY
 256   1              SREQ = 1;                                       // Port bit set for input -- REV G ONLY
 257   1              MISO = 1;                                       // Set for input
 258   1              MOSI = 1;         */
 259   1              
 260   1              // Counter/Timer 0 used as a Timer in Mode 1.  Interrupt Rate: 32mS     
 261   1              TH0 = 0;
 262   1              TL0 = 135;
 263   1              TR0 = ON;                                       // start timer 0
 264   1      
 265   1              // Counter/Timer 1 used as a Timer in Mode 1.  Interrupt Rate: 5e-3 Sec
 266   1              TL1 = LS_RELOAD_5mS;
 267   1              TH1 = MS_RELOAD_5mS;
 268   1              TMOD = 0x11;
 269   1      
 270   1              // Timer 2 used as count up counter for soft reset function, triggered when external reset button pushed
 271   1              T2CON = 0x02;                   // 0b00000010 -- set for counter operation, external trigger on T2 pin
 272   1              TH2 = 0xFF;                                     // set counter so single external trigger causes interrupt -> soft reset
 273   1              TL2 = 0xFF;
 274   1              RCAP2H = 0xFF;                          // same auto-reload values                              
 275   1              RCAP2L = 0xFF;
 276   1              TR2 = 1;                                        // start timer 2
 277   1      
 278   1              // Serial I/O Setup:  Using Internal Baud Rate Generator on 89C5131A.  Set to Serial Mode 1 at 9600 Baud 
             -using 24MHz Clock
 279   1          SCON = 0x50;                                // 0101 0000
 280   1              BDRCON = 0x1e;                          // 0001 1110
 281   1              CKCON0 = 0x7f;                          // X2 set but 12 clocks per peripheral cycle -> 500ns pert tick
 282   1              PCON = 0x80;                            // 1000 0000 Double Baud Rate all others default
 283   1              BRL = 100;                                      // Baud rate reload - sets Baud rate to 9600
 284   1      
 285   1              //PCA Counter Init                      // not implemented      - for getFanSpeed()
 286   1              //CKCON0 |= 0x20;                       // sets to 500ns per PCA tick
 287   1              //CMOD |= 0x81;                         // 1000 0001 Set PCA to stop counting during idle mode, disable PCA interrupts, and co
             -unt Fclk-periph/6 (250ns period)
 288   1              //CCON |= 0x01;                         // enable PCA interrupts 
 289   1      
 290   1              // LED Setup
 291   1              LEDCON = 0xfC;                          // LED1-3 10mA Current Source
 292   1              LED_FAULT = 0;                          // Off
 293   1      //      LED_STATUS = 1;                         // Off
 294   1              LED_STATUS = 0;                         // Used as test o/p
 295   1              LED_OUTON = 1;                          // Off
 296   1      
C51 COMPILER V8.02   SCUBA2PS                                                              01/23/2009 15:39:15 PAGE 6   

 297   1              // SPI Setup - Sets up spi in master mode with Fclk Periph/16 as baud rate and without slave select pin.
 298   1              // SPCON = SPI_MSTR | SPI_EN | SPI_SSDIS | SPI_CPOL1 | SPI_1M5Hz;       CPHA = 0, transfer on falling SCLK
 299   1          SPCON |= SPI_MSTR;          // Master mode    
 300   1              //SPCON |= SPI_6MHz;            // Fclk Periph/4 (6MHz)
 301   1          SPCON |= SPI_1M5Hz;                 // Fclk Periph/16 (1.5Mhz)
 302   1              SPCON &= SPI_CPOL0;             // CPOL = 0, Clk idle state 0
 303   1          SPCON &= SPI_CPHA0;         // CPHA = 0, sample data on Clk rising edge
 304   1          SPCON |= SPI_SSDIS;                 // Disable SS
 305   1          SPCON |= SPI_EN;            // Run SPI
 306   1          
 307   1              // Interrupt Setup
 308   1              ES = 1;                                         // Enable SIO Interrupts
 309   1              IEN1 |= 0x04;               // Enable SPI Interrupts
 310   1              ET0 = 1;                                // Enable Timer0 Interrupts
 311   1          ET1 = 1;                                    // Enable Timer1 Interrupts
 312   1      //      ET2 = 1;                                        // Enable Timer2 Interrupts
 313   1          EA = 1;                                     // Enable Global Interrupts
 314   1              //EC = 1;                                       // Enable all PCA Interrupts
 315   1      
 316   1              // Interrupt Priority Setup
 317   1              PT0L = 1;                                       // give Timer0 a higher priority
 318   1              
 319   1      
 320   1      /****************       Initialize Variables    ********************/           // Some of this is redundant                                                    
 321   1              // Initialize flags
 322   1              poll_data = SET;                        // Initial data poll
 323   1              cc_spi = CLEAR;                         // Clear remaining flags
 324   1              spi_complete = CLEAR;           // SPI transmission/reception complete status bit
 325   1              sio_msg_complete = CLEAR;
 326   1              timeup_T1 = CLEAR;
 327   1                      
 328   1              // Initialize other vars        
 329   1              spi_idx = 0;                            // Reset pointer for SPI data output
 330   1              sio_rx_idx = 0;                         // reset serial message pointer
 331   1              bcnt = 0;
 332   1              num_T1_ints = 0;
 333   1              running_checksum = 0;
 334   1              cc_req_320ms = 0;
 335   1              watchdog_count = 0;
 336   1              
 337   1              // Initialize pointers
 338   1              cc_command = NULL;
 339   1              msg_ptr = NULL;
 340   1                      
 341   1              // Initialize data blocks to all zeros
 342   1              for(i=0; i < CC_SPI_BLEN; i++) {                                
 343   2                              ps_data_blk[i] = 0;                                     
 344   2                              rcv_spi_blk[i] = 0;
 345   2              }
 346   1              for(i=0; i < BUF_SIZE; i++) {                           
 347   2                              sio_rxbuf[i] = 0;       
 348   2              }
 349   1              
 350   1              // Initialize PSU data block - these aspects of data block set only once
 351   1              ds_get_4byte_id(PSU_DS18S20, SILICON_ID);        // assign ID to PSU block
 352   1              *SOFTWARE_VERSION = software_version_byte;       // Software Version byte
 353   1       
 354   1      /*****************              Initialize Devices              ***************/        
 355   1              // check for presence of DS18S20 temperature sensors    
 356   1              temp1_present = ds_initialize(PSU_DS18S20);             
 357   1              temp2_present = ds_initialize(DTEMP1_ID);
 358   1              temp3_present = ds_initialize(DTEMP2_ID);       
C51 COMPILER V8.02   SCUBA2PS                                                              01/23/2009 15:39:15 PAGE 7   

 359   1      }
 360          
 361          /****************************************************************************************
 362           *  Turn-On (Startup) Sequence             *
 363           ***************************/
 364          
 365          void sequence_on (void)
 366          {
 367   1              //wait_time( T100mS );
 368   1              nPSU_ON = 0;
 369   1              wait_time( T100mS );
 370   1              nCORE_ON = 0;
 371   1              LED_OUTON = 0;                                                          // 0 = LED on
 372   1      }
 373          
 374          /****************************************************************************************
 375           *  Turn-Off Sequence              *
 376           *******************************/
 377          
 378          void sequence_off (void)
 379          {
 380   1              nCORE_ON = 1;
 381   1              wait_time( T100mS );
 382   1              nPSU_ON = 1;
 383   1          wait_time( T100mS );
 384   1              LED_OUTON = 1;                                                          // LED off
 385   1      }
 386          
 387          /****************************************************************************************
 388           *  Reset MCE      *
 389           *******************/
 390          
 391          void reset_MCE (void)
 392          {
 393   1              BRST = 1;                                       // Pulse Reset Line
 394   1      //      wait_time( 400 );                       // wait 2 second
 395   1              wait_time( 800 );                       // wait 4 second
 396   1              BRST = 0;
 397   1      }
 398          
 399          /****************************************************************************************
 400           *  Cycle Power            *
 401           ***********************/
 402          
 403          void cycle_power (void)
 404          {
 405   1              sequence_off();
 406   1      //      wait_time( 400 );                       // wait 2 seconds
 407   1              wait_time( 800 );                       // wait 4 seconds
 408   1              sequence_on();
 409   1      }
 410          
 411          /****************************************************************************************
 412          /*      Send PSU Data Block to CC via SPI          *
 413          /*******************************************/
 414          // Sends the 36 byte PSU Status Block to the CC via SPI interface while simultaneously 
 415          // receiving a command from the CC.  ACK/NAK byte near end of datablock indicates whether
 416          // a valid command was received during the SAME datablock transmission.
 417          
 418          void send_psu_data_block (void)
 419          {                               
 420   1              // Begin Transaction
C51 COMPILER V8.02   SCUBA2PS                                                              01/23/2009 15:39:15 PAGE 8   

 421   1              spi_idx = 0;                                                            // Start at beginning of data block
 422   1              CCSS = 0;                                                                       // Select Clock Card (as slave) to listen on SPI bus            
 423   1                              
 424   1              // Send first 34 of 36 bytes (need to calculate checksum based on ACK/NAK byte after CC command recv'd)
 425   1              while(spi_idx < ACK_BYTE_POS) {                         
 426   2                      SPDAT = ps_data_blk[spi_idx];                   // send byte #spi_idx
 427   2                      while(!spi_complete);                                   // wait for end of byte transmission
 428   2                      spi_complete = 0;                                               // clear software flag
 429   2                      spi_idx++;                                                              // increment data block index
 430   2              }
 431   1              
 432   1              // Update ACK/NAK byte and send
 433   1              parse_command();                                                        // Check if command received and set ACK/NAK byte
 434   1      
 435   1              // Send ACK/NAK byte
 436   1              SPDAT = ps_data_blk[ACK_BYTE_POS];              
 437   1              while(!spi_complete);                                           // wait for end of byte transmission
 438   1              spi_complete = 0;                                                       // clear software flag
 439   1              
 440   1              // Update Checkbyte and send            
 441   1              COMPLETE_CHECKSUM;                                                      // 2's compliment, so CHECKSUM_BYTE + all other bytes = 0       
 442   1              SPDAT = ps_data_blk[ACK_BYTE_POS + 1];          // Send Check byte
 443   1              while(!spi_complete);                                           // wait for end of byte transmission
 444   1              spi_complete = 0;                                                       // clear software flag
 445   1                      
 446   1              // Finish Transaction
 447   1              CCSS = 1;                                                                       // De-select Clock Card                                 
 448   1      }
 449          
 450          /****************************************************************************************
 451          /*  Wait Timer - 5ms Multiples             */
 452          /***************************************/
 453          //Sets up T1 interrupt to loops x 5mS, waits specified time then returns
 454           
 455          void wait_time (unsigned int loops)
 456          {
 457   1              timeup_T1 = CLEAR;
 458   1              TL1 = LS_RELOAD_5mS;                                            // Interrupt interval set to 5mS
 459   1              TH1 = MS_RELOAD_5mS;
 460   1              num_T1_ints = loops;                                            // time expires after 1 interrupt
 461   1              TR1 = ON;
 462   1              while ( timeup_T1 != SET );                                     // wait here for specified time to expire
 463   1      }
 464          
 465          /****************************************************************************************
 466          /*  Microsecond Wait Timer         */
 467          /***********************************/
 468          // returns 2*time_us_div2 + 3 (in uS)....tested and verified
 469          // therefore works for a minimum of 3us (time_us_div2 = 0) or maximum of 513us (time_us_div2 = 0xFF)
 470          // from numbers below, delay = time_us_div2 * (1.25+ 0.25 + 0.5) + 1.25+ 0.25 + 1 + 0.5 = 2*time_us_div2 +
             - 3 (in uS)
 471          
 472          void wait_time_x2us_plus3 (unsigned char time_us_div2)          // 1.25 us to call function
 473          {       
 474   1              while(time_us_div2>0) {                                         // each comparison takes 1.25 uS
 475   2                      time_us_div2--;                                                 // 250ns operation
 476   2              }                                                                                       // 500ns delay to begining of loop
 477   1              _nop_();                                                                        // 250 ns delay to make total delay an integer
 478   1      }                                                                                               // 500 ns to return from function
 479          
 480          /***************************************************************************************/
 481          /* Timer0 Service Routine                       */ 
C51 COMPILER V8.02   SCUBA2PS                                                              01/23/2009 15:39:15 PAGE 9   

 482          /****************************************/
 483          // Interrupt occurs every 32ms, always running    -  used for LED blink and polling data
 484          
 485          void timer0_isr (void) interrupt 1 using 3
 486          {
 487   1      //      if(watchdog_count>16)                                           // trigger watchdog if loop hasn't completed in 5 seconds
 488   1      //              { soft_reset();}
 489   1                      
 490   1              ++bcnt;
 491   1              if ( bcnt == BRATE320mS) {
 492   2      //      if ( bcnt >= BRATE1S) {
 493   2              bcnt = 0;
 494   2                      poll_data = SET;                                                // poll data every 320ms
 495   2                      cc_req_320ms++;                                                 // increment count every 320ms
 496   2      //              watchdog_count++;
 497   2         }
 498   1      }
 499          
 500          /***************************************************************************************/
 501          /* Timer1 Service Routine                       */ 
 502          /****************************************/
 503          // Interrupt occurs every 5ms when enabled       - used for wait_time()
 504          
 505          void timer1_isr (void) interrupt 3 using 3
 506          {
 507   1         --num_T1_ints;                                                               // count the number of interupts
 508   1         if (num_T1_ints == 0) {                                              // check if interrupt time is up
 509   2            TR1=OFF;                                                                  // Stop the timer
 510   2                timeup_T1 = SET;                                                      // Indicate time is up
 511   2         }
 512   1         else {                                                                               // reload timer
 513   2            TL1 = LS_RELOAD_5mS;                                              // interrupts always occur every 5mS
 514   2                TH1 = MS_RELOAD_5mS;
 515   2         }
 516   1      }
 517          
 518          /***************************************************************************************/
 519          /* Timer2 Service Routine                       */ 
 520          /****************************************/
 521          // Interrupt occurs ONLY when external SOFT RESET button pushed
 522          
 523          void timer2_isr (void) interrupt 5 using 0
 524          {
 525   1      //      LED_STATUS = ON;                // used as soft-reset test o/p; on P1-pin3
 526   1              TF2=0;                                                          // clear interrupt
 527   1      //      ET2 = OFF;                                                      // Disable Timer2 Interrupts until back in main loop
 528   1      //      soft_reset();                                           // reset program counter to jump point ( past init() )
 529   1      }
 530          
 531          
 532          /*=============================================================================================*/
 533          // RS232 Serial IO stuff
 534          
 535          #include <ctype.h>
 536          char echo[2] = "\000\000";
 537          
 538          unsigned char idata prt_data_blk[(CC_SPI_BLEN*2)+15];           // ps_data_blk printf output buffer
 539          
 540          /*----->convert a char value to 2 ascii hex char, store results at char *p */
 541          void ByteToHex( unsigned char idata b, char *p)
 542          {
 543   1              unsigned char mask = 0x0f;
C51 COMPILER V8.02   SCUBA2PS                                                              01/23/2009 15:39:15 PAGE 10  

 544   1              unsigned char idata c;
 545   1              
 546   1          c = (b>>4) & mask;                  // most signif char first for endian
 547   1              if (c<10) *p++ = ('0'+c);
 548   1              else      *p++ = ('A'+c-10);
 549   1              c = b & mask;
 550   1              if (c<10) *p++ = ('0'+c);
 551   1              else      *p++ = ('A'+c-10);
 552   1      }
 553          
 554          /*-----> print the ps_data_blk[] in hex */
 555          void sio_prt_datablk_hex(void)
 556          {
 557   1              unsigned char i, n;
 558   1                      
 559   1              n=0;
 560   1              prt_data_blk[n++] = '\r';
 561   1              prt_data_blk[n++] = '\r';
 562   1              prt_data_blk[n++] = ' ';
 563   1              prt_data_blk[n++] = ' ';
 564   1                              
 565   1                      for( i=0 ; i<(CC_SPI_BLEN) ; i++)
 566   1                              {
 567   2                              ByteToHex( ps_data_blk[i], prt_data_blk+n );
 568   2                              n += 2;
 569   2                              }
 570   1              prt_data_blk[n++] = '\r';
 571   1              prt_data_blk[n] = '\000';
 572   1              
 573   1              snd_msg(prt_data_blk);          // 
 574   1      }
 575          
 576          void sio_prt_volts_hex(void)
 577          {
 578   1              unsigned char i, x, n;
 579   1                      
 580   1              x=0;
 581   1              n=0;
 582   1              prt_data_blk[n++] = '\r';
 583   1              prt_data_blk[n++] = '\r';
 584   1              prt_data_blk[n++] = ' ';
 585   1              prt_data_blk[n++] = ' ';
 586   1      
 587   1      /*          for ( i=12 ; i<(CC_SPI_BLEN-14) ; i++ )               // prints hex block of voltages - no spaces, 
             -hard to read!
 588   1                          {   
 589   1                      ByteToHex( ps_data_blk[i], prt_data_blk+n ); 
 590   1                          n += 2;
 591   1                          }      */
 592   1      
 593   1                  for ( i=12 ; i<(CC_SPI_BLEN-14) ; i++ )               // prints hex block of voltages
 594   1                          {   
 595   2                      ByteToHex( ps_data_blk[i], prt_data_blk+n ); 
 596   2                          n += 2;                                     
 597   2      
 598   2                              x++;
 599   2      
 600   2                                if (x == 2) {
 601   3                            prt_data_blk[n++] = ' ';  
 602   3                                        x = 0;
 603   3                                   }  
 604   2                              }
C51 COMPILER V8.02   SCUBA2PS                                                              01/23/2009 15:39:15 PAGE 11  

 605   1              
 606   1              prt_data_blk[n++] = ' ';
 607   1              ByteToHex( *V_12VRAIL, prt_data_blk+n ); 
 608   1      
 609   1              n += 2;
 610   1      
 611   1              prt_data_blk[n++] = '\r';
 612   1              prt_data_blk[n] = '\000';
 613   1              
 614   1              snd_msg(prt_data_blk);          // 
 615   1      }
 616          
 617          void sio_prt_current_hex(void)
 618          {
 619   1              unsigned char i, x, n;
 620   1                      
 621   1              x=0;
 622   1              n=0;
 623   1              prt_data_blk[n++] = '\r';
 624   1              prt_data_blk[n++] = '\r';
 625   1              prt_data_blk[n++] = ' ';
 626   1              prt_data_blk[n++] = ' ';
 627   1      
 628   1                  for ( i=22 ; i<(CC_SPI_BLEN-4) ; i++ )               // prints hex block of current
 629   1                          {   
 630   2                      ByteToHex( ps_data_blk[i], prt_data_blk+n ); 
 631   2                          n += 2;                                     
 632   2      
 633   2                              x++;   
 634   2                                  if (x == 2) {
 635   3                             prt_data_blk[n++] = ' '; 
 636   3                                         x = 0;
 637   3                                     }
 638   2                              }
 639   1              
 640   1              prt_data_blk[n++] = ' ';
 641   1              ByteToHex( *I_12VRAIL, prt_data_blk+n );        
 642   1      
 643   1              n += 2;
 644   1                                      
 645   1              prt_data_blk[n++] = '\r';
 646   1              prt_data_blk[n] = '\000';
 647   1              
 648   1              snd_msg(prt_data_blk);          // 
 649   1      }
 650          
 651          
 652          /*-----> print the ps_data_blk[] Temperatures in hex */
 653          void sio_prt_temps_hex(void)
 654          {
 655   1              unsigned char n;
 656   1                      
 657   1              n=0;
 658   1              prt_data_blk[n++] = '\r';
 659   1              prt_data_blk[n++] = '\r';
 660   1              prt_data_blk[n++] = '\t';
 661   1                              
 662   1              ByteToHex( *PSU_TEMP_1, prt_data_blk+n ); n += 2;       // 
 663   1              prt_data_blk[n++] = ' ';
 664   1              ByteToHex( *PSU_TEMP_2, prt_data_blk+n ); n += 2;
 665   1              prt_data_blk[n++] = ' ';
 666   1              ByteToHex( *PSU_TEMP_3, prt_data_blk+n ); n += 2;
C51 COMPILER V8.02   SCUBA2PS                                                              01/23/2009 15:39:15 PAGE 12  

 667   1                      
 668   1              prt_data_blk[n++] = '\r';
 669   1              prt_data_blk[n] = '\000';
 670   1              
 671   1              snd_msg(prt_data_blk);          // 
 672   1      }
 673          
 674          // PSU volts and current measurments calibration factors, V/ADU, A/ADU
 675          /**/
 676          #define CF_pVha          (float)0.003051
 677          #define CF_pVa           (float)0.001892
 678          #define CF_pVlvd         (float)0.001373
 679          #define CF_pVcore        (float)0.000824
 680          #define CF_nVa           (float)0.001892
 681          #define CF_p12VRail  (float)0.058594             // added v4.0
 682          // Amp/ADU
 683          #define CF_pIVha         (float)0.0001018
 684          #define CF_pIVa          (float)0.003662
 685          #define CF_pIVlvd        (float)0.0008129
 686          #define CF_pIVcore       (float)0.0024414
 687          #define CF_nIVa          (float)0.0008129
 688          #define CF_pI12VRail (float)0.071484             // added v4.0
 689          
 690          #define ushort unsigned short
 691          
 692          /*----->  ItoA assumes an unsigned short that is from a float scaled * 100, to provide a fixed 2 decimal p
             -laces */ 
 693          unsigned char ItoA(unsigned short n, unsigned char *buf)
 694          {
 695   1      unsigned char i;
 696   1       
 697   1              // only/always 5 char: 2 digits, a '.' 2 more digits , plus a terminating NULL
 698   1              // done in reverse order, starting with a NULL, then the LSD, so [4-i] as the index
 699   1           buf[5]=0;
 700   1           for(i=0; i<5; i++){
 701   2                      if( i == 2) buf[4-i] = '.';
 702   2                      else {
 703   3                              buf[4-i] = (n%10)+48;   // take the remainer of a div by 10, convert to ascii
 704   3                              n/=10;
 705   3                      }
 706   2          }
 707   1              return 5;
 708   1       }
 709          
 710          /*-----> output the sensed & converted PSU current values from the data block */
 711          void sio_prt_currents(void)
 712          {
 713   1              ushort i;
 714   1              unsigned char n;
 715   1                      
 716   1              n=0;
 717   1              prt_data_blk[n++] = '\r';
 718   1              prt_data_blk[n++] = '\r';
 719   1              prt_data_blk[n++] = '\t';
 720   1              
 721   1              i = *(ushort*)I_VCORE;                          // +3.0
 722   1              i = (ushort)((float)i * CF_pIVcore * 100);              // convert to 'real' value, * 100 for 2 decimal places
 723   1              n += ItoA( i, prt_data_blk+n );         
 724   1              prt_data_blk[n++] = ' ';                        // insert a space between values
 725   1              i = *(ushort*)I_VLVD;                           // +4.5
 726   1              i = (ushort)((float)i * CF_pIVlvd * 100);       
 727   1              n += ItoA( i, prt_data_blk+n );         
C51 COMPILER V8.02   SCUBA2PS                                                              01/23/2009 15:39:15 PAGE 13  

 728   1              prt_data_blk[n++] = ' ';
 729   1              i = *(ushort*)I_VAH;                            // +10.0
 730   1              i = (ushort)((float)i * CF_pIVha * 100);
 731   1              n += ItoA( i, prt_data_blk+n );         
 732   1              prt_data_blk[n++] = ' ';
 733   1              i = *(ushort*)I_VA_PLUS;                        // +6.2
 734   1              i = (ushort)((float)i * CF_pIVa * 100); 
 735   1              n += ItoA( i, prt_data_blk+n );         
 736   1              prt_data_blk[n++] = ' ';
 737   1              prt_data_blk[n++] = '-';                        // next value is from negative supply, so insert a '-'
 738   1              i = *(ushort*)I_VA_MINUS;                       // -6.2
 739   1              i = (ushort)((float)i * CF_nIVa * 100); 
 740   1              n += ItoA( i, prt_data_blk+n );         
 741   1      
 742   1      /*      prt_data_blk[n++] = ' ';
 743   1              i = *(ushort*)I_12VRAIL;                        // +12V Rail
 744   1              i = (ushort)((float)i * CF_pI12VRail * 100);    
 745   1              n += ItoA( i, prt_data_blk+n );         */
 746   1      
 747   1              prt_data_blk[n++] = '\r';
 748   1              prt_data_blk[n] = '\000';
 749   1              snd_msg(prt_data_blk);          // 
 750   1      }
 751          
 752          /*-----> output the sensed & converted PSU voltage values from the data block */
 753          void sio_prt_volts(void)
 754          {
 755   1              ushort v;
 756   1              unsigned char n;
 757   1                      
 758   1              n=0;
 759   1              prt_data_blk[n++] = '\r';
 760   1              prt_data_blk[n++] = '\r';
 761   1              prt_data_blk[n++] = '\t';
 762   1              
 763   1          v = *(ushort*)V_VCORE;                              // +3.0
 764   1              v = (ushort)((float)v * CF_pVcore * 100);               // convert to 'real' value, * 100 for 2 decimal places
 765   1              n += ItoA( v, prt_data_blk+n );         
 766   1              prt_data_blk[n++] = ' ';
 767   1              v = *(ushort*)V_VLVD;                           // +4.5
 768   1              v = (ushort)((float)v * CF_pVlvd * 100);        
 769   1              n += ItoA( v, prt_data_blk+n );         
 770   1              prt_data_blk[n++] = ' ';
 771   1              v = *(ushort*)V_VAH;                            // +10.0
 772   1              v = (ushort)((float)v * CF_pVa * 100);
 773   1              n += ItoA( v, prt_data_blk+n );         
 774   1              prt_data_blk[n++] = ' ';
 775   1              v = *(ushort*)V_VA_PLUS;                        // +6.2
 776   1              v = (ushort)((float)v * CF_pVa * 100);  
 777   1              n += ItoA( v, prt_data_blk+n );         
 778   1              prt_data_blk[n++] = ' ';
 779   1              prt_data_blk[n++] = '-';
 780   1              v = *(ushort*)V_VA_MINUS;                       // -6.2
 781   1              v = (ushort)((float)v * CF_nVa * 100);  
 782   1              n += ItoA( v, prt_data_blk+n );         
 783   1              
 784   1      /*      prt_data_blk[n++] = ' ';
 785   1          v = *(ushort*)V_12VRAIL;                    // +12V Rail  RL
 786   1              v = (ushort)((float)v * CF_p12VRail * 100);     
 787   1              n += ItoA( v, prt_data_blk+n );     */
 788   1      
 789   1              prt_data_blk[n++] = '\r';
C51 COMPILER V8.02   SCUBA2PS                                                              01/23/2009 15:39:15 PAGE 14  

 790   1              prt_data_blk[n] = '\000';
 791   1              snd_msg(prt_data_blk);          // 
 792   1      }
 793          
 794          
 795          /***************************************************************************************/
 796          /* Send Serial Message     */ 
 797          /***************************/
 798          
 799          void snd_msg (char *message)
 800          {
 801   1              while( msg_ptr != 0 ) ;                         //if currently sending wait for it to end.
 802   1              msg_ptr = message;
 803   1              TI = SET;                                                       // Generates SIO interrupt
 804   1      }
 805          
 806          /***************************************************************************************/
 807          /* Serial Interrupt Service Routine     */ 
 808          /****************************************/
 809          // Interrupt driven serial I/O
 810          
 811          //void serial_isr (void) interrupt 4 using 2
 812          void serial_isr (void) interrupt 4 using 1      // changed to 'using 1' RHJ
 813          {
 814   1              char c;
 815   1              
 816   1              // Transmitted Data Interrupt
 817   1              if ( TI == SET ) {                              
 818   2              TI = CLEAR;                                                             // Clears TI Interrupt
 819   2                      c = *msg_ptr;
 820   2                      if (c != NULL) {                                                // If message not NULL, load into transmission buffer 
 821   3                      ++msg_ptr;
 822   3                              SBUF = c;       
 823   3                      }
 824   2                      else msg_ptr = 0;
 825   2              }       
 826   1         
 827   1              // Received Data Interrupt
 828   1              if ( RI == SET ) {                                      
 829   2              RI = CLEAR;                                                     // Clears RI Interrupt
 830   2                      c = SBUF;                                                       // get the rcved char
 831   2                      if(isprint(c))                                          // if isprint, echo it,
 832   2                              {
 833   3                              echo[0]  = c;
 834   3                              msg_ptr = echo;                 
 835   3                              TI = SET;                                               //  TI Interrupt to tx
 836   3                              sio_rxbuf[sio_rx_idx++] = c;    // and add it to the rxbuf
 837   3                              }
 838   2                      if (sio_rx_idx >= (BUF_SIZE-1))         // *****these three lines are suspect, need to fix
 839   2                      --sio_rx_idx;                                   // if rcved string is too long go back and maybe overwrite
 840   2                              
 841   2                      if (c == '\r') {                                        // CR indicates end of message
 842   3                      sio_rx_idx = 0;                                 // 
 843   3                      sio_msg_complete = SET;                 // Indicate entire message received
 844   3                      }
 845   2              }   
 846   1      }
 847          
 848          /*=============================================================================================*/
 849          
 850          /***************************************************************************************/
 851          /* SPI Interrupt Service Routine     */ 
C51 COMPILER V8.02   SCUBA2PS                                                              01/23/2009 15:39:15 PAGE 15  

 852          /*************************************/
 853          // read and clear spi status register
 854          
 855          void spi_isr (void) interrupt 9 using 2         // added 'using 2' RHJ
 856          {
 857   1              switch( SPSTA )                                 
 858   1              {
 859   2                      // SPIF flag set --> transmission complete
 860   2                      case 0x80:                                                              
 861   2                      rcv_spi_blk[spi_idx] = SPDAT;           // read receive data
 862   2                              spi_complete = 1;                                       // indicate transaction finished
 863   2                              break;
 864   2      
 865   2                      /* error cases -> refer to pg. 96 in AT89 datasheet */
 866   2                      // mode fault
 867   2                      case 0x10:                                                      
 868   2                      // this does not apply as single master on SPI bus and SSDisable bit set in SPSTA register                                      
             -                                                                                                                                
 869   2                              break;
 870   2              
 871   2                      // write collision
 872   2                      case 0x40:                                                      
 873   2                      // write collision does NOT cause an interrupt therefore this should be elsewhere if needed
 874   2                              // currently ONLY the function send_psu_data_block() ever writes to SPDAT so write collision not possib
             -le                                                                                                         
 875   2                              break;
 876   2      
 877   2                      default:
 878   2                              break;
 879   2              }
 880   1      }
 881                          
 882          /***************************************************************************************/
 883          /* Retrieve Data Block       */ 
 884          /*****************************/  
 885          //Updates PSU Data Block with Current Values
 886          
 887          void update_data_block (void)
 888          {
 889   1              // Fan Speeds
 890   1              // get_fan_speeds();                                                                            // not implemented
 891   1      
 892   1              // DS18S20 - Temperatures - read only if present
 893   1              ds_get_temperature(PSUC_DS18S20, PSU_TEMP_1);                           // always read PSUC DS = temperature 1
 894   1              
 895   1              if (temp1_present)
 896   1                      ds_get_temperature(PSU_DS18S20, PSU_TEMP_2);                    // temperature 2 
 897   1              
 898   1              if (temp3_present)
 899   1                      ds_get_temperature(DTEMP2_ID, PSU_TEMP_3);                              // temperature 3
 900   1      
 901   1              /*** ADC - Voltage and Current Readings - refer to documentation ***/
 902   1              // Ground reading scaled to 2mV per division (+/- 2.047V range)
 903   1              //read_adc(ADC_CH5, ADC_BI_5V, VOLTAGE, ADC_OFFSET);                    // Grounded ADC input channel reading (bipolar)
 904   1              
 905   1              // Voltages scaled to ~80% of nominal values, unipolar
 906   1              read_adc(ADC_CH0, ADC_UNI_5V, VOLTAGE, V_VCORE, 2);                     // +Vcore supply scaled
 907   1              read_adc(ADC_CH1, ADC_UNI_5V, VOLTAGE, V_VLVD, 2);                      // +Vlvd supply scaled
 908   1              read_adc(ADC_CH2, ADC_UNI_5V, VOLTAGE, V_VAH, 2);                       // +Vah supply scaled
 909   1              read_adc(ADC_CH3, ADC_UNI_5V, VOLTAGE, V_VA_PLUS, 2);           // +Va supply scaled
 910   1              read_adc(ADC_CH4, ADC_UNI_5V, VOLTAGE, V_VA_MINUS, 2);          // -Va supply scaled
 911   1              read_adc(ADC_CH5, ADC_UNI_5V, VOLTAGE, V_12VRAIL, 1);           // 12V Rail scaled 
C51 COMPILER V8.02   SCUBA2PS                                                              01/23/2009 15:39:15 PAGE 16  

 912   1      
 913   1              // Currents scaled to ~60% of nominal values, unipolar
 914   1              read_adc(ADC_CH0, ADC_UNI_5V, CURRENT, I_VCORE, 2);                     // Current +Vcore supply
 915   1              read_adc(ADC_CH1, ADC_UNI_5V, CURRENT, I_VLVD, 2);                      // Current +Vlvd supply
 916   1              read_adc(ADC_CH2, ADC_UNI_5V, CURRENT, I_VAH, 2);                       // Current +Vah supply
 917   1              read_adc(ADC_CH3, ADC_UNI_5V, CURRENT, I_VA_PLUS, 2);           // Current +Va supply
 918   1              read_adc(ADC_CH4, ADC_UNI_5V, CURRENT, I_VA_MINUS, 2);          // Current -Va supply    
 919   1          read_adc(ADC_CH5, ADC_UNI_5V, CURRENT, I_12VRAIL, 1);               // Current 12V Rail supply
 920   1              
 921   1              // release SCLK
 922   1              SCLK = 1;                                                                                                        //**needed for SPI in send_psu_data_block to work**                                                                                                                                                                            
 923   1              
 924   1              // Bookkeeping 
 925   1                      //Status Word currently not used (initialized to 0)
 926   1              // *STATUS_WORD = 0;                                                                            // undefined status word - higher byte
 927   1              // *(STATUS_WORD+1) = 0;                                                                        // undefined status word - lower byte
 928   1              
 929   1              // Check Digit pre-Calculation
 930   1              check_digit();                                                                                          // updates running checksum total - done here for quick response in send_data_b
             -lock()
 931   1      }
 932          
 933          /***************************************************************************************/
 934          /* Generate Check Digit    */ 
 935          /***************************/
 936          // Implemented as checksum for now to optimize calculation speed (tradeoff for sub-optimal error detection
             -)
 937          // Checksum byte totals 0 when summed with the other 35 bytes in the PSU data block  (ignoring addition ov
             -erflow)
 938          // *** This function calculated total of first 34 bytes in checksum
 939          // *** Finish checksum calculation and set in data block using COMPLETE_CHECKSUM macro (**AFTER** ACK/NAK 
             -byte has been set)
 940           
 941          void check_digit (void)
 942          {
 943   1              int j;
 944   1              running_checksum = 0;                                                                           // reset checksum
 945   1              for(j = 0; j < ACK_BYTE_POS; j++) {                                                     // sum PSU data block up to ACK/NAK byte
 946   2                      running_checksum += ps_data_blk[j];
 947   2              }
 948   1      }
 949          
 950          /***************************************************************************************/
 951          /* Parse Command Received from CC    */ 
 952          /*************************************/
 953          // could to make this more robust - varying degrees of complexity in how to implement this
 954          // current protocol receives 3 2-byte command in first 6 bytes of PSU Data Block transaction
 955          
 956          void parse_command(void)                 
 957          {
 958   1              //assume commands are in first 6 bytes of received SPI block, ordered and repeated thrice
 959   1              if ( commands_match(rcv_spi_blk, rcv_spi_blk+2,rcv_spi_blk+4) && command_valid(rcv_spi_blk) ) { 
 960   2                      cc_command = rcv_spi_blk;       
 961   2      //              *ACK_NAK = ACK;                                                                                 // ACK command if valid command received in triplicate  
 962   2              }       
 963   1              
 964   1              else {
 965   2                      cc_command = NULL;                                                                              // else NAK command
 966   2      //              *ACK_NAK = NAK;
 967   2              }
 968   1      }
 969          
C51 COMPILER V8.02   SCUBA2PS                                                              01/23/2009 15:39:15 PAGE 17  

 970          /***************************************************************************************/
 971          /* Matching Commands Check    */ 
 972          /******************************/
 973          // returns true if three matching commands sent else false
 974          
 975          bit commands_match (char *com_ptr_1, char *com_ptr_2, char *com_ptr_3)
 976          {
 977   1              if( (*com_ptr_1 == *com_ptr_2) && (*(com_ptr_1 + 1) == *(com_ptr_2 + 1)) ) {    // first two commands match
 978   2                      
 979   2                      if( (*com_ptr_1 == *com_ptr_3) && (*(com_ptr_1 + 1) == *(com_ptr_3 + 1)) )      // third command matches
 980   2                              return TRUE;
 981   2                      else
 982   2                              return FALSE;
 983   2              }
 984   1              
 985   1              else
 986   1                      return FALSE;
 987   1      }
 988          
 989          /***************************************************************************************/
 990          /* Valid Command Check    */ 
 991          /****************************************/
 992          // returns true if command received is valid
 993          
 994          bit command_valid (char *com_ptr)
 995          {
 996   1              // If command is valid return TRUE
 997   1              if( (*com_ptr == 0) && (*(com_ptr+1) == 0) )                            // Request Status Command (default)
 998   1                      return TRUE;
 999   1              else if( (*com_ptr == 'C') && (*(com_ptr+1) == 'P') )           // Cycle Power Command
1000   1                      return TRUE;
1001   1              else if( (*com_ptr == 'R') && (*(com_ptr+1) == 'M') )           // Reset MCE Command
1002   1                      return TRUE;
1003   1              else if( (*com_ptr == 'T') && (*(com_ptr+1) == 'O') )           // Turn Off Command
1004   1                      return TRUE;    
1005   1              else
1006   1                      return FALSE;
1007   1      }
C51 COMPILER V8.02   SCUBA2PS                                                              01/23/2009 15:39:15 PAGE 18  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


P0 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0080H  1
msg_ptr. . . . . . . . . . . . . . . .  PUBLIC   PDATA  PTR      0000H  3
P1 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0090H  1
P2 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A0H  1
P3 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B0H  1
P4 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C0H  1
timer0_isr . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
SPCON. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C3H  1
timer1_isr . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
EA . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00AFH  1
timer2_isr . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
command_lsb. . . . . . . . . . . . . .  ABSBIT   -----  BIT      0000H  1
ds_write_bit . . . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
  com_bit. . . . . . . . . . . . . . .  AUTO     DATA   BIT      0000H  1
_read_adc. . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     000AH  -----
  chan . . . . . . . . . . . . . . . .  AUTO     DATA   CHAR     0007H  1
  mode . . . . . . . . . . . . . . . .  AUTO     DATA   CHAR     0005H  1
  adc_sel. . . . . . . . . . . . . . .  AUTO     DATA   BIT      0000H  1
  target . . . . . . . . . . . . . . .  AUTO     PDATA  PTR      0002H  3
  data_size. . . . . . . . . . . . . .  AUTO     PDATA  CHAR     0005H  1
  bit_cnt. . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0005H  1
  temp_char_ptr. . . . . . . . . . . .  AUTO     PDATA  PTR      0006H  3
  adc_reading. . . . . . . . . . . . .  AUTO     PDATA  U_INT    0009H  2
CS_IADC. . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0091H  1
cc_command . . . . . . . . . . . . . .  PUBLIC   PDATA  PTR      0003H  3
spi_complete . . . . . . . . . . . . .  PUBLIC   DATA   BIT      0000H  1
SPSTA. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C4H  1
IEN0 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A8H  1
IEN1 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B1H  1
size_t . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_INT    -----  2
sio_prt_current_hex. . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  i. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0004H  1
  x. . . . . . . . . . . . . . . . . .  AUTO     PDATA  U_CHAR   0000H  1
  n. . . . . . . . . . . . . . . . . .  AUTO     PDATA  U_CHAR   0001H  1
rcv_spi_blk. . . . . . . . . . . . . .  PUBLIC   IDATA  ARRAY    0000H  36
CS_VADC. . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B2H  1
IPL0 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B8H  1
nCORE_ON . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A7H  1
ES . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00ACH  1
RI . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0098H  1
sequence_on. . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
LED_STATUS . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B7H  1
TI . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0099H  1
command_bit_adr. . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0000H  1
CKCON0 . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008FH  1
echo . . . . . . . . . . . . . . . . .  PUBLIC   PDATA  ARRAY    0006H  2
sio_prt_volts. . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  v. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0006H  2
  n. . . . . . . . . . . . . . . . . .  AUTO     PDATA  U_CHAR   0000H  1
PT0L . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B9H  1
RCAP2H . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CBH  1
cycle_power. . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
CCON . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D8H  1
prompt . . . . . . . . . . . . . . . .  PUBLIC   CODE   ARRAY    0008H  7
adc_data . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0001H  1
RCAP2L . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CAH  1
main . . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
C51 COMPILER V8.02   SCUBA2PS                                                              01/23/2009 15:39:15 PAGE 19  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


_commands_match. . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  com_ptr_1. . . . . . . . . . . . . .  AUTO     PDATA  PTR      0000H  3
  com_ptr_2. . . . . . . . . . . . . .  AUTO     PDATA  PTR      0003H  3
  com_ptr_3. . . . . . . . . . . . . .  AUTO     PDATA  PTR      0006H  3
bcnt . . . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0000H  1
_wait_time . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0004H  -----
  loops. . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0006H  2
CCSS . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0094H  1
SCLK . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0096H  1
PCON . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0087H  1
SBUF . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0099H  1
serial_isr . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  c. . . . . . . . . . . . . . . . . .  AUTO     PDATA  CHAR     0000H  1
LED_FAULT. . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B5H  1
SCON . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0098H  1
sio_msg_complete . . . . . . . . . . .  PUBLIC   DATA   BIT      0001H  1
TMOD . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0089H  1
TCON . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0088H  1
poll_data. . . . . . . . . . . . . . .  PUBLIC   DATA   BIT      0002H  1
init . . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  i. . . . . . . . . . . . . . . . . .  * REG *  DATA   INT      0006H  2
_command_valid . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  com_ptr. . . . . . . . . . . . . . .  * REG *  DATA   PTR      0001H  3
LEDCON . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F1H  1
sio_prt_temps_hex. . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  n. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0004H  1
MOSI . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0097H  1
MISO . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0095H  1
BDRCON . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   009BH  1
BRST . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A0H  1
SREQ . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0093H  1
running_checksum . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0001H  1
sio_rx_idx . . . . . . . . . . . . . .  PUBLIC   DATA   CHAR     0002H  1
adr_mask . . . . . . . . . . . . . . .  PUBLIC   PDATA  U_CHAR   0008H  1
cc_req_320ms . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0003H  1
sio_prt_volts_hex. . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  i. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0004H  1
  x. . . . . . . . . . . . . . . . . .  AUTO     PDATA  U_CHAR   0000H  1
  n. . . . . . . . . . . . . . . . . .  AUTO     PDATA  U_CHAR   0001H  1
ET0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A9H  1
read_bus . . . . . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
ET1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00ABH  1
TF2. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00CFH  1
TH0. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008CH  1
LED_OUTON. . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B6H  1
TH1. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008DH  1
_ItoA. . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0023H  -----
  n. . . . . . . . . . . . . . . . . .  AUTO     PDATA  U_INT    0000H  2
  buf. . . . . . . . . . . . . . . . .  AUTO     PDATA  PTR      0002H  3
  i. . . . . . . . . . . . . . . . . .  AUTO     PDATA  U_CHAR   0005H  1
ADC_MS_DBIT. . . . . . . . . . . . . .  ABSBIT   -----  BIT      000FH  1
TH2. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CDH  1
_snd_msg . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0006H  -----
  message. . . . . . . . . . . . . . .  AUTO     PDATA  PTR      0000H  3
temp1_present. . . . . . . . . . . . .  PUBLIC   DATA   BIT      0003H  1
TL0. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008AH  1
temp2_present. . . . . . . . . . . . .  PUBLIC   DATA   BIT      0004H  1
C51 COMPILER V8.02   SCUBA2PS                                                              01/23/2009 15:39:15 PAGE 20  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


_ds_initialize . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  mask . . . . . . . . . . . . . . . .  * REG *  DATA   CHAR     0007H  1
  present. . . . . . . . . . . . . . .  AUTO     DATA   BIT      0000H  1
TL1. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008BH  1
temp3_present. . . . . . . . . . . . .  PUBLIC   DATA   BIT      0005H  1
send_psu_data_block. . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
TL2. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CCH  1
_ds_get_4byte_id . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  mask . . . . . . . . . . . . . . . .  * REG *  DATA   CHAR     0007H  1
  target . . . . . . . . . . . . . . .  AUTO     PDATA  PTR      0000H  3
  presence_detect. . . . . . . . . . .  AUTO     DATA   BIT      0000H  1
  family_code. . . . . . . . . . . . .  AUTO     PDATA  U_CHAR   0003H  1
  serial_number. . . . . . . . . . . .  AUTO     PDATA  ARRAY    0004H  6
  crc_code . . . . . . . . . . . . . .  AUTO     PDATA  U_CHAR   000AH  1
TR0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      008CH  1
sio_rxbuf. . . . . . . . . . . . . . .  PUBLIC   IDATA  ARRAY    0024H  10
UEPINT . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F8H  1
TR1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      008EH  1
num_T1_ints. . . . . . . . . . . . . .  PUBLIC   DATA   U_INT    0004H  2
TR2. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00CAH  1
reset_MCE. . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
_ds_write_byte . . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
  command. . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
  a. . . . . . . . . . . . . . . . . .  AUTO     PDATA  INT      0000H  2
ds_reset . . . . . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
  presence . . . . . . . . . . . . . .  AUTO     DATA   BIT      0000H  1
BRL. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   009AH  1
_ByteToHex . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     000BH  -----
  b. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
  p. . . . . . . . . . . . . . . . . .  AUTO     PDATA  PTR      0000H  3
  mask . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0006H  1
  c. . . . . . . . . . . . . . . . . .  AUTO     IDATA  U_CHAR   0000H  1
sio_prt_currents . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  i. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0006H  2
  n. . . . . . . . . . . . . . . . . .  AUTO     PDATA  U_CHAR   0000H  1
parse_command. . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
watchdog_count . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0006H  1
sio_prt_datablk_hex. . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  i. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0004H  1
  n. . . . . . . . . . . . . . . . . .  AUTO     PDATA  U_CHAR   0000H  1
nPSU_ON. . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A1H  1
T2CON. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C8H  1
_isprint . . . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
ds_read_byte . . . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
  b. . . . . . . . . . . . . . . . . .  AUTO     PDATA  INT      0000H  2
  read_temp. . . . . . . . . . . . . .  AUTO     PDATA  U_CHAR   0002H  1
prt_data_blk . . . . . . . . . . . . .  PUBLIC   IDATA  ARRAY    002EH  87
_ds_get_temperature. . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  mask . . . . . . . . . . . . . . . .  * REG *  DATA   CHAR     0007H  1
  target . . . . . . . . . . . . . . .  AUTO     PDATA  PTR      0000H  3
  value. . . . . . . . . . . . . . . .  AUTO     PDATA  U_CHAR   0003H  1
  sign . . . . . . . . . . . . . . . .  AUTO     PDATA  U_CHAR   0004H  1
update_data_block. . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
ds_convert_T . . . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
software_version_byte. . . . . . . . .  PUBLIC   CODE   CHAR     0007H  1
helpmsg. . . . . . . . . . . . . . . .  PUBLIC   CODE   ARRAY    000FH  233
cc_spi . . . . . . . . . . . . . . . .  PUBLIC   DATA   BIT      0006H  1
C51 COMPILER V8.02   SCUBA2PS                                                              01/23/2009 15:39:15 PAGE 21  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


spi_idx. . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0007H  1
check_digit. . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  j. . . . . . . . . . . . . . . . . .  * REG *  DATA   INT      0006H  2
ds_read_bit. . . . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
  temp_bit . . . . . . . . . . . . . .  AUTO     DATA   BIT      0000H  1
_wait_time_x2us_plus3. . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  time_us_div2 . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
ps_data_blk. . . . . . . . . . . . . .  PUBLIC   IDATA  ARRAY    0085H  36
sequence_off . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
spi_isr. . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
timeup_T1. . . . . . . . . . . . . . .  PUBLIC   DATA   BIT      0007H  1
SPDAT. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C5H  1


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3594    ----
   CONSTANT SIZE    =    248    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =      9      61
   DATA SIZE        =     10    ----
   IDATA SIZE       =    169       1
   BIT SIZE         =      8       6
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  2 WARNING(S),  0 ERROR(S)
